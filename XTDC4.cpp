/*----- PROTECTED REGION ID(XTDC4.cpp) ENABLED START -----*/
static const char *RcsId = "$Id:  $";
//=============================================================================
//
// file :        XTDC4.cpp
//
// description : C++ source for the XTDC4 class and its commands.
//               The class is derived from Device. It represents the
//               CORBA servant object which will be accessed from the
//               network. All commands which can be executed on the
//               XTDC4 are implemented in this file.
//
// project :     xTDC4_DevServer
//
// This file is part of Tango device class.
// 
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
// 
// $Author:  $
//
// $Revision:  $
// $Date:  $
//
// $HeadURL:  $
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================



#include <XTDC4.h>
#include <XTDC4Class.h>
#include <thread>

// this inclused proprietary xTDC4 libray by chronologic
#include "xTDC4_interface.h"


/*----- PROTECTED REGION END -----*/	//	XTDC4.cpp

/**
 *  XTDC4 class description:
 *    https://www.cronologic.de/time_measurement/tdc/xtdc4/
 */

//================================================================
//  The following table gives the correspondence
//  between command and method names.
//
//  Command name  |  Method name
//================================================================
//  State         |  Inherited (no method)
//  Status        |  Inherited (no method)
//  Start         |  start
//  Stop          |  stop
//  Off           |  off
//  apply_config  |  apply_config
//  Clear         |  clear
//================================================================

//================================================================
//  Attributes managed are:
//================================================================
//  error_code                         |  Tango::DevLong	Scalar
//  error_message                      |  Tango::DevString	Scalar
//  device_type                        |  Tango::DevShort	Scalar
//  START_RISING                       |  Tango::DevBoolean	Scalar
//  START_DC_OFFSET                    |  Tango::DevDouble	Scalar
//  CH0_ENABLED                        |  Tango::DevBoolean	Scalar
//  CH0_RISING                         |  Tango::DevBoolean	Scalar
//  CH0_DC_OFFSET                      |  Tango::DevDouble	Scalar
//  CH1_ENABLED                        |  Tango::DevBoolean	Scalar
//  CH1_RISING                         |  Tango::DevBoolean	Scalar
//  CH1_DC_OFFSET                      |  Tango::DevDouble	Scalar
//  CH2_ENABLED                        |  Tango::DevBoolean	Scalar
//  CH2_RISING                         |  Tango::DevBoolean	Scalar
//  CH2_DC_OFFSET                      |  Tango::DevDouble	Scalar
//  CH3_ENABLED                        |  Tango::DevBoolean	Scalar
//  CH3_RISING                         |  Tango::DevBoolean	Scalar
//  CH3_DC_OFFSET                      |  Tango::DevDouble	Scalar
//  TW_START                           |  Tango::DevLong64	Scalar
//  TW_END                             |  Tango::DevLong64	Scalar
//  config_changed                     |  Tango::DevBoolean	Scalar
//  start_trigger_generator            |  Tango::DevBoolean	Scalar
//  last_run_valid_starts              |  Tango::DevLong	Scalar
//  last_run_empty_starts              |  Tango::DevLong	Scalar
//  last_run_hits                      |  Tango::DevLong	Scalar
//  last_run_start_errors              |  Tango::DevLong	Scalar
//  start_trigger_generator_frequency  |  Tango::DevLong	Scalar
//  run_timeout                        |  Tango::DevDouble	Scalar
//  firmware_revision                  |  Tango::DevLong	Scalar
//  driver_version                     |  Tango::DevLong	Scalar
//  board_serial                       |  Tango::DevLong	Scalar
//  bin_size                           |  Tango::DevDouble	Scalar
//  CH0_Timestamps                     |  Tango::DevULong64	Spectrum  ( max = 1400000)
//  CH1_Timestamps                     |  Tango::DevULong64	Spectrum  ( max = 1400000)
//  CH2_Timestamps                     |  Tango::DevULong64	Spectrum  ( max = 1400000)
//  CH3_Timestamps                     |  Tango::DevULong64	Spectrum  ( max = 1400000)
//================================================================

namespace XTDC4_ns
{
/*----- PROTECTED REGION ID(XTDC4::namespace_starting) ENABLED START -----*/
//	static initializations

xtdc4_device * this_device_ref;

#define NUMBER_OF_EXPOSED_CHANNELS 4
#define MAX_TIMESTAMPS_BUFFER_SIZE 1400000 // this is a number generated by pogo, too bad it is not defined by it!
std::queue <datachunk*> datachunk_list[NUMBER_OF_EXPOSED_CHANNELS];

int bTerminatePolingThread;
std::thread * poller_thread_ref;
__int64 run_timeout_ticks;
__int64 first_start_timestamp;

/*----- PROTECTED REGION END -----*/	//	XTDC4::namespace_starting

//--------------------------------------------------------
/**
 *	Method      : XTDC4::XTDC4()
 *	Description : Constructors for a Tango device
 *                implementing the classXTDC4
 */
//--------------------------------------------------------
XTDC4::XTDC4(Tango::DeviceClass *cl, string &s)
 : TANGO_BASE_CLASS(cl, s.c_str())
{
	/*----- PROTECTED REGION ID(XTDC4::constructor_1) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::constructor_1
}
//--------------------------------------------------------
XTDC4::XTDC4(Tango::DeviceClass *cl, const char *s)
 : TANGO_BASE_CLASS(cl, s)
{
	/*----- PROTECTED REGION ID(XTDC4::constructor_2) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::constructor_2
}
//--------------------------------------------------------
XTDC4::XTDC4(Tango::DeviceClass *cl, const char *s, const char *d)
 : TANGO_BASE_CLASS(cl, s, d)
{
	/*----- PROTECTED REGION ID(XTDC4::constructor_3) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::constructor_3
}

//--------------------------------------------------------
/**
 *	Method      : XTDC4::delete_device()
 *	Description : will be called at device destruction or at init command
 */
//--------------------------------------------------------
void XTDC4::delete_device()
{
	DEBUG_STREAM << "XTDC4::delete_device() " << device_name << endl;
	/*----- PROTECTED REGION ID(XTDC4::delete_device) ENABLED START -----*/
	

	// must terminate the polling thread if still running
	if (state() == Tango::DevState::RUNNING || state() == Tango::DevState::STANDBY)
	{
		bTerminatePolingThread = 1;
		while (state() == Tango::DevState::RUNNING || state() == Tango::DevState::STANDBY) 
			// when terminated gracefully, the thread sets bTerminatePolingThread back to zero
		{
			Sleep(10);
		}
	}

	//	Delete device allocated objects
	xtdc4_close(this_device_ref);
	set_state(Tango::DevState::OFF);

	// clear the output buffer queue (and delete its datachunks)
	clear();
	
	delete[] attr_error_message_read[0]; // unallocate memory for error message

	/*----- PROTECTED REGION END -----*/	//	XTDC4::delete_device
	delete[] attr_error_code_read;
	delete[] attr_error_message_read;
	delete[] attr_device_type_read;
	delete[] attr_START_RISING_read;
	delete[] attr_START_DC_OFFSET_read;
	delete[] attr_CH0_ENABLED_read;
	delete[] attr_CH0_RISING_read;
	delete[] attr_CH0_DC_OFFSET_read;
	delete[] attr_CH1_ENABLED_read;
	delete[] attr_CH1_RISING_read;
	delete[] attr_CH1_DC_OFFSET_read;
	delete[] attr_CH2_ENABLED_read;
	delete[] attr_CH2_RISING_read;
	delete[] attr_CH2_DC_OFFSET_read;
	delete[] attr_CH3_ENABLED_read;
	delete[] attr_CH3_RISING_read;
	delete[] attr_CH3_DC_OFFSET_read;
	delete[] attr_TW_START_read;
	delete[] attr_TW_END_read;
	delete[] attr_config_changed_read;
	delete[] attr_start_trigger_generator_read;
	delete[] attr_last_run_valid_starts_read;
	delete[] attr_last_run_empty_starts_read;
	delete[] attr_last_run_hits_read;
	delete[] attr_last_run_start_errors_read;
	delete[] attr_start_trigger_generator_frequency_read;
	delete[] attr_run_timeout_read;
	delete[] attr_firmware_revision_read;
	delete[] attr_driver_version_read;
	delete[] attr_board_serial_read;
	delete[] attr_bin_size_read;
	delete[] attr_CH0_Timestamps_read;
	delete[] attr_CH1_Timestamps_read;
	delete[] attr_CH2_Timestamps_read;
	delete[] attr_CH3_Timestamps_read;
}

//--------------------------------------------------------
/**
 *	Method      : XTDC4::init_device()
 *	Description : will be called at device initialization.
 */
//--------------------------------------------------------
void XTDC4::init_device()
{
	DEBUG_STREAM << "XTDC4::init_device() create device " << device_name << endl;
	/*----- PROTECTED REGION ID(XTDC4::init_device_before) ENABLED START -----*/

	//	Initialization before get_device_property() call
	bTerminatePolingThread = 0;
	/*----- PROTECTED REGION END -----*/	//	XTDC4::init_device_before
	

	//	Get the device properties from database
	get_device_property();
	
	attr_error_code_read = new Tango::DevLong[1];
	attr_error_message_read = new Tango::DevString[1];
	attr_device_type_read = new Tango::DevShort[1];
	attr_START_RISING_read = new Tango::DevBoolean[1];
	attr_START_DC_OFFSET_read = new Tango::DevDouble[1];
	attr_CH0_ENABLED_read = new Tango::DevBoolean[1];
	attr_CH0_RISING_read = new Tango::DevBoolean[1];
	attr_CH0_DC_OFFSET_read = new Tango::DevDouble[1];
	attr_CH1_ENABLED_read = new Tango::DevBoolean[1];
	attr_CH1_RISING_read = new Tango::DevBoolean[1];
	attr_CH1_DC_OFFSET_read = new Tango::DevDouble[1];
	attr_CH2_ENABLED_read = new Tango::DevBoolean[1];
	attr_CH2_RISING_read = new Tango::DevBoolean[1];
	attr_CH2_DC_OFFSET_read = new Tango::DevDouble[1];
	attr_CH3_ENABLED_read = new Tango::DevBoolean[1];
	attr_CH3_RISING_read = new Tango::DevBoolean[1];
	attr_CH3_DC_OFFSET_read = new Tango::DevDouble[1];
	attr_TW_START_read = new Tango::DevLong64[1];
	attr_TW_END_read = new Tango::DevLong64[1];
	attr_config_changed_read = new Tango::DevBoolean[1];
	attr_start_trigger_generator_read = new Tango::DevBoolean[1];
	attr_last_run_valid_starts_read = new Tango::DevLong[1];
	attr_last_run_empty_starts_read = new Tango::DevLong[1];
	attr_last_run_hits_read = new Tango::DevLong[1];
	attr_last_run_start_errors_read = new Tango::DevLong[1];
	attr_start_trigger_generator_frequency_read = new Tango::DevLong[1];
	attr_run_timeout_read = new Tango::DevDouble[1];
	attr_firmware_revision_read = new Tango::DevLong[1];
	attr_driver_version_read = new Tango::DevLong[1];
	attr_board_serial_read = new Tango::DevLong[1];
	attr_bin_size_read = new Tango::DevDouble[1];
	attr_CH0_Timestamps_read = new Tango::DevULong64[1400000];
	attr_CH1_Timestamps_read = new Tango::DevULong64[1400000];
	attr_CH2_Timestamps_read = new Tango::DevULong64[1400000];
	attr_CH3_Timestamps_read = new Tango::DevULong64[1400000];
	/*----- PROTECTED REGION ID(XTDC4::init_device) ENABLED START -----*/

	//	Initialize device
	xtdc4_init_parameters params;
	xtdc4_get_default_init_parameters(&params);
	params.buffer_size[0] = buffer_size;	   // packet buffer
	params.board_id = board_id;						// number copied to "card" field of every packet, allowed range 0..255
	params.card_index = card_index;						// ordering depends on PCIe slot position if more than one card is present
	params.use_ext_clock = use_ext_clock;					// 0: internal 10 MHz reference	// 1: external 10 MHz reference connected to J12
	// initialize card
	int error_code;
	const char * error_message;
	this_device_ref = xtdc4_init(&params, &error_code, &error_message);
	attr_error_code_read[0] = error_code;
	attr_error_message_read[0] = new char[255];
	strcpy_s(attr_error_message_read[0], 255, error_message);
	
	if (error_code != CRONO_OK)
	{
		set_state(Tango::DevState::FAULT);
	}
	else
	{
		set_state(Tango::DevState::ON);
	}

	

	// fill in default config values. When the device is first installed, these will be read.
	attr_START_RISING_read[0]=0;
	attr_START_DC_OFFSET_read[0] = 0;
	attr_CH0_ENABLED_read[0] = 0;
	attr_CH0_RISING_read[0] = 0;
	attr_CH0_DC_OFFSET_read[0] = 0;
	attr_CH1_ENABLED_read[0] = 0;
	attr_CH1_RISING_read[0] = 0;
	attr_CH1_DC_OFFSET_read[0] = 0;
	attr_CH2_ENABLED_read[0] = 0;
	attr_CH2_RISING_read[0] = 0;
	attr_CH2_DC_OFFSET_read[0] = 0;
	attr_CH3_ENABLED_read[0] = 0;
	attr_CH3_RISING_read[0] = 0;
	attr_CH3_DC_OFFSET_read[0] = 0;
	attr_TW_START_read[0] = 0;
	attr_TW_END_read[0] = 0x3fffffff;

	attr_config_changed_read[0] = 1;

	attr_start_trigger_generator_read[0] = 0; // internal trigger disabled at startup
	attr_start_trigger_generator_frequency_read[0] = 2000; // 2kHz default 

	attr_last_run_valid_starts_read[0] = 0;
	attr_last_run_empty_starts_read[0] = 0;
	attr_last_run_hits_read[0] = 0;
	attr_last_run_start_errors_read[0] = 0;

	attr_run_timeout_read[0] = 0;
	// apply default config
	apply_config();

	// read device hardware parameters
	attr_device_type_read[0] = xtdc4_get_device_type(this_device_ref);

	xtdc4_static_info st_info;
	xtdc4_get_static_info(this_device_ref, &st_info);
	attr_firmware_revision_read[0] = st_info.firmware_revision;
	attr_driver_version_read[0] = st_info.driver_revision;
	attr_board_serial_read[0] = st_info.board_serial;

	xtdc4_param_info p_info;
	xtdc4_get_param_info(this_device_ref, &p_info);
	attr_bin_size_read[0] = p_info.binsize;
	/*----- PROTECTED REGION END -----*/	//	XTDC4::init_device
}

//--------------------------------------------------------
/**
 *	Method      : XTDC4::get_device_property()
 *	Description : Read database to initialize property data members.
 */
//--------------------------------------------------------
void XTDC4::get_device_property()
{
	/*----- PROTECTED REGION ID(XTDC4::get_device_property_before) ENABLED START -----*/
	
	//	Initialize property data members
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::get_device_property_before


	//	Read device properties from database.
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("buffer_size"));
	dev_prop.push_back(Tango::DbDatum("board_id"));
	dev_prop.push_back(Tango::DbDatum("card_index"));
	dev_prop.push_back(Tango::DbDatum("use_ext_clock"));

	//	is there at least one property to be read ?
	if (dev_prop.size()>0)
	{
		//	Call database and extract values
		if (Tango::Util::instance()->_UseDb==true)
			get_db_device()->get_property(dev_prop);
	
		//	get instance on XTDC4Class to get class property
		Tango::DbDatum	def_prop, cl_prop;
		XTDC4Class	*ds_class =
			(static_cast<XTDC4Class *>(get_device_class()));
		int	i = -1;

		//	Try to initialize buffer_size from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  buffer_size;
		else {
			//	Try to initialize buffer_size from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  buffer_size;
		}
		//	And try to extract buffer_size value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  buffer_size;

		//	Try to initialize board_id from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  board_id;
		else {
			//	Try to initialize board_id from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  board_id;
		}
		//	And try to extract board_id value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  board_id;

		//	Try to initialize card_index from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  card_index;
		else {
			//	Try to initialize card_index from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  card_index;
		}
		//	And try to extract card_index value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  card_index;

		//	Try to initialize use_ext_clock from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  use_ext_clock;
		else {
			//	Try to initialize use_ext_clock from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  use_ext_clock;
		}
		//	And try to extract use_ext_clock value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  use_ext_clock;

	}

	/*----- PROTECTED REGION ID(XTDC4::get_device_property_after) ENABLED START -----*/
	
	//	Check device property data members init
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::get_device_property_after
}

//--------------------------------------------------------
/**
 *	Method      : XTDC4::always_executed_hook()
 *	Description : method always executed before any command is executed
 */
//--------------------------------------------------------
void XTDC4::always_executed_hook()
{
	DEBUG_STREAM << "XTDC4::always_executed_hook()  " << device_name << endl;
	/*----- PROTECTED REGION ID(XTDC4::always_executed_hook) ENABLED START -----*/
	
	//	code always executed before all requests
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::always_executed_hook
}

//--------------------------------------------------------
/**
 *	Method      : XTDC4::read_attr_hardware()
 *	Description : Hardware acquisition for attributes
 */
//--------------------------------------------------------
void XTDC4::read_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "XTDC4::read_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(XTDC4::read_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::read_attr_hardware
}
//--------------------------------------------------------
/**
 *	Method      : XTDC4::write_attr_hardware()
 *	Description : Hardware writing for attributes
 */
//--------------------------------------------------------
void XTDC4::write_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "XTDC4::write_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(XTDC4::write_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::write_attr_hardware
}

//--------------------------------------------------------
/**
 *	Read attribute error_code related method
 *	Description: 
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::read_error_code(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XTDC4::read_error_code(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(XTDC4::read_error_code) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_error_code_read);
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::read_error_code
}
//--------------------------------------------------------
/**
 *	Read attribute error_message related method
 *	Description: 
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::read_error_message(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XTDC4::read_error_message(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(XTDC4::read_error_message) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_error_message_read);
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::read_error_message
}
//--------------------------------------------------------
/**
 *	Read attribute device_type related method
 *	Description: For xTDC4, the device type is 6
 *
 *	Data type:	Tango::DevShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::read_device_type(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XTDC4::read_device_type(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(XTDC4::read_device_type) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_device_type_read);
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::read_device_type
}
//--------------------------------------------------------
/**
 *	Read attribute START_RISING related method
 *	Description: Trigger START on rising of falling edge
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::read_START_RISING(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XTDC4::read_START_RISING(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(XTDC4::read_START_RISING) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_START_RISING_read);
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::read_START_RISING
}
//--------------------------------------------------------
/**
 *	Write attribute START_RISING related method
 *	Description: Trigger START on rising of falling edge
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::write_START_RISING(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "XTDC4::write_START_RISING(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(XTDC4::write_START_RISING) ENABLED START -----*/
	attr_START_RISING_read[0] = w_val;
	attr_config_changed_read[0] = 1;
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::write_START_RISING
}
//--------------------------------------------------------
/**
 *	Read attribute START_DC_OFFSET related method
 *	Description: DC threshold of START input
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::read_START_DC_OFFSET(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XTDC4::read_START_DC_OFFSET(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(XTDC4::read_START_DC_OFFSET) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_START_DC_OFFSET_read);
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::read_START_DC_OFFSET
}
//--------------------------------------------------------
/**
 *	Write attribute START_DC_OFFSET related method
 *	Description: DC threshold of START input
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::write_START_DC_OFFSET(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "XTDC4::write_START_DC_OFFSET(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(XTDC4::write_START_DC_OFFSET) ENABLED START -----*/
	attr_START_DC_OFFSET_read[0] = w_val;
	attr_config_changed_read[0] = 1;
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::write_START_DC_OFFSET
}
//--------------------------------------------------------
/**
 *	Read attribute CH0_ENABLED related method
 *	Description: Enable input
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::read_CH0_ENABLED(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XTDC4::read_CH0_ENABLED(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(XTDC4::read_CH0_ENABLED) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_CH0_ENABLED_read);
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::read_CH0_ENABLED
}
//--------------------------------------------------------
/**
 *	Write attribute CH0_ENABLED related method
 *	Description: Enable input
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::write_CH0_ENABLED(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "XTDC4::write_CH0_ENABLED(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(XTDC4::write_CH0_ENABLED) ENABLED START -----*/
	attr_CH0_ENABLED_read[0] = w_val;
	attr_config_changed_read[0] = 1;
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::write_CH0_ENABLED
}
//--------------------------------------------------------
/**
 *	Read attribute CH0_RISING related method
 *	Description: Trigger input on rising of falling edge
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::read_CH0_RISING(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XTDC4::read_CH0_RISING(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(XTDC4::read_CH0_RISING) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_CH0_RISING_read);
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::read_CH0_RISING
}
//--------------------------------------------------------
/**
 *	Write attribute CH0_RISING related method
 *	Description: Trigger input on rising of falling edge
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::write_CH0_RISING(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "XTDC4::write_CH0_RISING(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(XTDC4::write_CH0_RISING) ENABLED START -----*/
	attr_CH0_RISING_read[0] = w_val;
	attr_config_changed_read[0] = 1;
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::write_CH0_RISING
}
//--------------------------------------------------------
/**
 *	Read attribute CH0_DC_OFFSET related method
 *	Description: DC threshold of input
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::read_CH0_DC_OFFSET(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XTDC4::read_CH0_DC_OFFSET(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(XTDC4::read_CH0_DC_OFFSET) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_CH0_DC_OFFSET_read);
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::read_CH0_DC_OFFSET
}
//--------------------------------------------------------
/**
 *	Write attribute CH0_DC_OFFSET related method
 *	Description: DC threshold of input
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::write_CH0_DC_OFFSET(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "XTDC4::write_CH0_DC_OFFSET(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(XTDC4::write_CH0_DC_OFFSET) ENABLED START -----*/
	attr_CH0_DC_OFFSET_read[0] = w_val;
	attr_config_changed_read[0] = 1;
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::write_CH0_DC_OFFSET
}
//--------------------------------------------------------
/**
 *	Read attribute CH1_ENABLED related method
 *	Description: Enable input
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::read_CH1_ENABLED(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XTDC4::read_CH1_ENABLED(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(XTDC4::read_CH1_ENABLED) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_CH1_ENABLED_read);
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::read_CH1_ENABLED
}
//--------------------------------------------------------
/**
 *	Write attribute CH1_ENABLED related method
 *	Description: Enable input
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::write_CH1_ENABLED(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "XTDC4::write_CH1_ENABLED(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(XTDC4::write_CH1_ENABLED) ENABLED START -----*/
	attr_CH1_ENABLED_read[0] = w_val;
	attr_config_changed_read[0] = 1;
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::write_CH1_ENABLED
}
//--------------------------------------------------------
/**
 *	Read attribute CH1_RISING related method
 *	Description: Trigger input on rising of falling edge
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::read_CH1_RISING(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XTDC4::read_CH1_RISING(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(XTDC4::read_CH1_RISING) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_CH1_RISING_read);
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::read_CH1_RISING
}
//--------------------------------------------------------
/**
 *	Write attribute CH1_RISING related method
 *	Description: Trigger input on rising of falling edge
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::write_CH1_RISING(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "XTDC4::write_CH1_RISING(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(XTDC4::write_CH1_RISING) ENABLED START -----*/
	attr_CH1_RISING_read[0] = w_val;
	attr_config_changed_read[0] = 1;
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::write_CH1_RISING
}
//--------------------------------------------------------
/**
 *	Read attribute CH1_DC_OFFSET related method
 *	Description: DC threshold of input
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::read_CH1_DC_OFFSET(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XTDC4::read_CH1_DC_OFFSET(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(XTDC4::read_CH1_DC_OFFSET) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_CH1_DC_OFFSET_read);
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::read_CH1_DC_OFFSET
}
//--------------------------------------------------------
/**
 *	Write attribute CH1_DC_OFFSET related method
 *	Description: DC threshold of input
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::write_CH1_DC_OFFSET(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "XTDC4::write_CH1_DC_OFFSET(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(XTDC4::write_CH1_DC_OFFSET) ENABLED START -----*/
	attr_CH1_DC_OFFSET_read[0] = w_val;
	attr_config_changed_read[0] = 1;
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::write_CH1_DC_OFFSET
}
//--------------------------------------------------------
/**
 *	Read attribute CH2_ENABLED related method
 *	Description: Enable input
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::read_CH2_ENABLED(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XTDC4::read_CH2_ENABLED(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(XTDC4::read_CH2_ENABLED) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_CH2_ENABLED_read);
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::read_CH2_ENABLED
}
//--------------------------------------------------------
/**
 *	Write attribute CH2_ENABLED related method
 *	Description: Enable input
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::write_CH2_ENABLED(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "XTDC4::write_CH2_ENABLED(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(XTDC4::write_CH2_ENABLED) ENABLED START -----*/
	attr_CH2_ENABLED_read[0] = w_val;
	attr_config_changed_read[0] = 1;
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::write_CH2_ENABLED
}
//--------------------------------------------------------
/**
 *	Read attribute CH2_RISING related method
 *	Description: Trigger input on rising of falling edge
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::read_CH2_RISING(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XTDC4::read_CH2_RISING(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(XTDC4::read_CH2_RISING) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_CH2_RISING_read);
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::read_CH2_RISING
}
//--------------------------------------------------------
/**
 *	Write attribute CH2_RISING related method
 *	Description: Trigger input on rising of falling edge
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::write_CH2_RISING(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "XTDC4::write_CH2_RISING(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(XTDC4::write_CH2_RISING) ENABLED START -----*/
	attr_CH2_RISING_read[0] = w_val;
	attr_config_changed_read[0] = 1;
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::write_CH2_RISING
}
//--------------------------------------------------------
/**
 *	Read attribute CH2_DC_OFFSET related method
 *	Description: DC threshold of input
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::read_CH2_DC_OFFSET(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XTDC4::read_CH2_DC_OFFSET(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(XTDC4::read_CH2_DC_OFFSET) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_CH2_DC_OFFSET_read);
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::read_CH2_DC_OFFSET
}
//--------------------------------------------------------
/**
 *	Write attribute CH2_DC_OFFSET related method
 *	Description: DC threshold of input
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::write_CH2_DC_OFFSET(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "XTDC4::write_CH2_DC_OFFSET(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(XTDC4::write_CH2_DC_OFFSET) ENABLED START -----*/
	attr_CH2_DC_OFFSET_read[0] = w_val;
	attr_config_changed_read[0] = 1;
	/*----- PROTECTED REGION END -----*/	//	XTDC4::write_CH2_DC_OFFSET
}
//--------------------------------------------------------
/**
 *	Read attribute CH3_ENABLED related method
 *	Description: Enable input
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::read_CH3_ENABLED(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XTDC4::read_CH3_ENABLED(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(XTDC4::read_CH3_ENABLED) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_CH3_ENABLED_read);
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::read_CH3_ENABLED
}
//--------------------------------------------------------
/**
 *	Write attribute CH3_ENABLED related method
 *	Description: Enable input
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::write_CH3_ENABLED(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "XTDC4::write_CH3_ENABLED(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(XTDC4::write_CH3_ENABLED) ENABLED START -----*/
	attr_CH3_ENABLED_read[0] = w_val;
	attr_config_changed_read[0] = 1;
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::write_CH3_ENABLED
}
//--------------------------------------------------------
/**
 *	Read attribute CH3_RISING related method
 *	Description: Trigger input on rising of falling edge
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::read_CH3_RISING(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XTDC4::read_CH3_RISING(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(XTDC4::read_CH3_RISING) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_CH3_RISING_read);
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::read_CH3_RISING
}
//--------------------------------------------------------
/**
 *	Write attribute CH3_RISING related method
 *	Description: Trigger input on rising of falling edge
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::write_CH3_RISING(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "XTDC4::write_CH3_RISING(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(XTDC4::write_CH3_RISING) ENABLED START -----*/
	attr_CH3_RISING_read[0] = w_val;
	attr_config_changed_read[0] = 1;
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::write_CH3_RISING
}
//--------------------------------------------------------
/**
 *	Read attribute CH3_DC_OFFSET related method
 *	Description: DC threshold of input
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::read_CH3_DC_OFFSET(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XTDC4::read_CH3_DC_OFFSET(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(XTDC4::read_CH3_DC_OFFSET) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_CH3_DC_OFFSET_read);
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::read_CH3_DC_OFFSET
}
//--------------------------------------------------------
/**
 *	Write attribute CH3_DC_OFFSET related method
 *	Description: DC threshold of input
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::write_CH3_DC_OFFSET(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "XTDC4::write_CH3_DC_OFFSET(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(XTDC4::write_CH3_DC_OFFSET) ENABLED START -----*/
	attr_CH3_DC_OFFSET_read[0] = w_val;
	attr_config_changed_read[0] = 1;
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::write_CH3_DC_OFFSET
}
//--------------------------------------------------------
/**
 *	Read attribute TW_START related method
 *	Description: Timestamps smaller than TW_START will not be recorded
 *
 *	Data type:	Tango::DevLong64
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::read_TW_START(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XTDC4::read_TW_START(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(XTDC4::read_TW_START) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_TW_START_read);
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::read_TW_START
}
//--------------------------------------------------------
/**
 *	Write attribute TW_START related method
 *	Description: Timestamps smaller than TW_START will not be recorded
 *
 *	Data type:	Tango::DevLong64
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::write_TW_START(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "XTDC4::write_TW_START(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevLong64	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(XTDC4::write_TW_START) ENABLED START -----*/
	attr_TW_START_read[0] = w_val;
	attr_config_changed_read[0] = 1;
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::write_TW_START
}
//--------------------------------------------------------
/**
 *	Read attribute TW_END related method
 *	Description: Timestamps larger than TW_END will not be recorded
 *
 *	Data type:	Tango::DevLong64
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::read_TW_END(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XTDC4::read_TW_END(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(XTDC4::read_TW_END) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_TW_END_read);
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::read_TW_END
}
//--------------------------------------------------------
/**
 *	Write attribute TW_END related method
 *	Description: Timestamps larger than TW_END will not be recorded
 *
 *	Data type:	Tango::DevLong64
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::write_TW_END(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "XTDC4::write_TW_END(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevLong64	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(XTDC4::write_TW_END) ENABLED START -----*/
	attr_TW_END_read[0] = w_val;
	attr_config_changed_read[0] = 1;
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::write_TW_END
}
//--------------------------------------------------------
/**
 *	Read attribute config_changed related method
 *	Description: 
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::read_config_changed(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XTDC4::read_config_changed(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(XTDC4::read_config_changed) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_config_changed_read);
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::read_config_changed
}
//--------------------------------------------------------
/**
 *	Read attribute start_trigger_generator related method
 *	Description: Whether to use an internal trigger generator. Frequency controlled by another attribute. Currently hardcoded to 13.2 ns width positive TTL logic. If TRUE, START becomes an output
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::read_start_trigger_generator(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XTDC4::read_start_trigger_generator(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(XTDC4::read_start_trigger_generator) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_start_trigger_generator_read);
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::read_start_trigger_generator
}
//--------------------------------------------------------
/**
 *	Write attribute start_trigger_generator related method
 *	Description: Whether to use an internal trigger generator. Frequency controlled by another attribute. Currently hardcoded to 13.2 ns width positive TTL logic. If TRUE, START becomes an output
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::write_start_trigger_generator(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "XTDC4::write_start_trigger_generator(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(XTDC4::write_start_trigger_generator) ENABLED START -----*/
	attr_start_trigger_generator_read[0] = w_val;
	attr_config_changed_read[0] = 1;
	/*----- PROTECTED REGION END -----*/	//	XTDC4::write_start_trigger_generator
}
//--------------------------------------------------------
/**
 *	Read attribute last_run_valid_starts related method
 *	Description: 
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::read_last_run_valid_starts(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XTDC4::read_last_run_valid_starts(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(XTDC4::read_last_run_valid_starts) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_last_run_valid_starts_read);
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::read_last_run_valid_starts
}
//--------------------------------------------------------
/**
 *	Read attribute last_run_empty_starts related method
 *	Description: 
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::read_last_run_empty_starts(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XTDC4::read_last_run_empty_starts(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(XTDC4::read_last_run_empty_starts) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_last_run_empty_starts_read);
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::read_last_run_empty_starts
}
//--------------------------------------------------------
/**
 *	Read attribute last_run_hits related method
 *	Description: 
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::read_last_run_hits(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XTDC4::read_last_run_hits(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(XTDC4::read_last_run_hits) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_last_run_hits_read);
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::read_last_run_hits
}
//--------------------------------------------------------
/**
 *	Read attribute last_run_start_errors related method
 *	Description: 
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::read_last_run_start_errors(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XTDC4::read_last_run_start_errors(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(XTDC4::read_last_run_start_errors) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_last_run_start_errors_read);
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::read_last_run_start_errors
}
//--------------------------------------------------------
/**
 *	Read attribute start_trigger_generator_frequency related method
 *	Description: Frequency of internal trigger, in Hz
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::read_start_trigger_generator_frequency(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XTDC4::read_start_trigger_generator_frequency(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(XTDC4::read_start_trigger_generator_frequency) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_start_trigger_generator_frequency_read);
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::read_start_trigger_generator_frequency
}
//--------------------------------------------------------
/**
 *	Write attribute start_trigger_generator_frequency related method
 *	Description: Frequency of internal trigger, in Hz
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::write_start_trigger_generator_frequency(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "XTDC4::write_start_trigger_generator_frequency(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevLong	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(XTDC4::write_start_trigger_generator_frequency) ENABLED START -----*/
	attr_start_trigger_generator_frequency_read[0] = w_val;
	attr_config_changed_read[0] = 1;
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::write_start_trigger_generator_frequency
}
//--------------------------------------------------------
/**
 *	Read attribute run_timeout related method
 *	Description: The acquisition run timeout. The timer is started by the first start pulse. To stop on timeout it requires at least one start pulse to arrive after timeout elapsed. 
 *               The device might still be busy for approx 100-200ms after that, but no timestamps are recorded.
 *               Set run_timeout to zero for infinite run
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::read_run_timeout(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XTDC4::read_run_timeout(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(XTDC4::read_run_timeout) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_run_timeout_read);
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::read_run_timeout
}
//--------------------------------------------------------
/**
 *	Write attribute run_timeout related method
 *	Description: The acquisition run timeout. The timer is started by the first start pulse. To stop on timeout it requires at least one start pulse to arrive after timeout elapsed. 
 *               The device might still be busy for approx 100-200ms after that, but no timestamps are recorded.
 *               Set run_timeout to zero for infinite run
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::write_run_timeout(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "XTDC4::write_run_timeout(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(XTDC4::write_run_timeout) ENABLED START -----*/
	attr_run_timeout_read[0] = w_val;
	attr_config_changed_read[0] = 1;
	/*----- PROTECTED REGION END -----*/	//	XTDC4::write_run_timeout
}
//--------------------------------------------------------
/**
 *	Read attribute firmware_revision related method
 *	Description: Revision number of the FPGA configuration.
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::read_firmware_revision(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XTDC4::read_firmware_revision(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(XTDC4::read_firmware_revision) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_firmware_revision_read);
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::read_firmware_revision
}
//--------------------------------------------------------
/**
 *	Read attribute driver_version related method
 *	Description: Encoded version number.
 *               The lower three bytes contain a triple level hierarchy of version numbers, e.g. 0x010103 encodes
 *               version 1.1.3.
 *               A change in the first digit generally requires a recompilation of user applications. Change in the
 *               second digit denote significant improvements or changes that don't break compatibility and the
 *               third digit changes with minor bug fixes and similar updates.
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::read_driver_version(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XTDC4::read_driver_version(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(XTDC4::read_driver_version) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_driver_version_read);
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::read_driver_version
}
//--------------------------------------------------------
/**
 *	Read attribute board_serial related method
 *	Description: Serial number.
 *               With year and running number in 8.24 format. The number is identical to the one printed on
 *               the silvery sticker on the board.
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::read_board_serial(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XTDC4::read_board_serial(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(XTDC4::read_board_serial) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_board_serial_read);
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::read_board_serial
}
//--------------------------------------------------------
/**
 *	Read attribute bin_size related method
 *	Description: Bin size (in ps) of the measured TDC data. The TDC main clock is running at
 *               a frequency of 76.8 GHz resulting in a bin size of about 13.0208ps.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void XTDC4::read_bin_size(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XTDC4::read_bin_size(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(XTDC4::read_bin_size) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_bin_size_read);
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::read_bin_size
}
//--------------------------------------------------------
/**
 *	Read attribute CH0_Timestamps related method
 *	Description: 
 *
 *	Data type:	Tango::DevULong64
 *	Attr type:	Spectrum max = 1400000
 */
//--------------------------------------------------------
void XTDC4::read_CH0_Timestamps(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XTDC4::read_CH0_Timestamps(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(XTDC4::read_CH0_Timestamps) ENABLED START -----*/
	//	Set the attribute value
	unsigned long nTimestamps = 0;

	prepare_channel_timestamps_to_send(0, attr_CH0_Timestamps_read, &nTimestamps);

	/*while (!datachunk_list[channel].empty())
	{
		//if (datachunk_list_lock[channel])//the queue is being written. Wait a bit and repeat.
		//{									
		//	Sleep(1);
		//	continue;
		//}
		if ((datachunk_list[channel].size() < 2) && state() != Tango::DevState::ON) // never read last element unless acquisition is ended. Thus no racing conditions.
		{
			break;
		}
		datachunk * chunk = datachunk_list[channel].front();
		if (chunk->size() + nTimestamps >= MAX_TIMESTAMPS_BUFFER_SIZE)
		{
			break; // output buffer full, next chunk does not fit. Wait until next time
		}

		datachunk_list[channel].pop(); // this deletes the pointer to datachunk from the queue
		// but the chunk itself still exist; copy it to the output

		std::copy_n(&((*chunk)[0]), chunk->size(), attr_CH0_Timestamps_read + nTimestamps);
		nTimestamps += chunk->size();

		chunk->clear();
		delete chunk; // this should delete the datachunk itself
	}*/
	//std::cout << nTimestamps << endl;
	//std::cout << attr_CH0_Timestamps_read[0] << endl;
	attr.set_value(attr_CH0_Timestamps_read, nTimestamps);
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::read_CH0_Timestamps
}
//--------------------------------------------------------
/**
 *	Read attribute CH1_Timestamps related method
 *	Description: 
 *
 *	Data type:	Tango::DevULong64
 *	Attr type:	Spectrum max = 1400000
 */
//--------------------------------------------------------
void XTDC4::read_CH1_Timestamps(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XTDC4::read_CH1_Timestamps(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(XTDC4::read_CH1_Timestamps) ENABLED START -----*/
	unsigned long nTimestamps = 0;

	prepare_channel_timestamps_to_send(1, attr_CH1_Timestamps_read, &nTimestamps);

	//	Set the attribute value
	attr.set_value(attr_CH1_Timestamps_read, nTimestamps);
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::read_CH1_Timestamps
}
//--------------------------------------------------------
/**
 *	Read attribute CH2_Timestamps related method
 *	Description: 
 *
 *	Data type:	Tango::DevULong64
 *	Attr type:	Spectrum max = 1400000
 */
//--------------------------------------------------------
void XTDC4::read_CH2_Timestamps(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XTDC4::read_CH2_Timestamps(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(XTDC4::read_CH2_Timestamps) ENABLED START -----*/
	unsigned long nTimestamps = 0;
	prepare_channel_timestamps_to_send(2, attr_CH2_Timestamps_read, &nTimestamps);
	//	Set the attribute value
	attr.set_value(attr_CH2_Timestamps_read, nTimestamps);
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::read_CH2_Timestamps
}
//--------------------------------------------------------
/**
 *	Read attribute CH3_Timestamps related method
 *	Description: 
 *
 *	Data type:	Tango::DevULong64
 *	Attr type:	Spectrum max = 1400000
 */
//--------------------------------------------------------
void XTDC4::read_CH3_Timestamps(Tango::Attribute &attr)
{
	DEBUG_STREAM << "XTDC4::read_CH3_Timestamps(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(XTDC4::read_CH3_Timestamps) ENABLED START -----*/
	unsigned long nTimestamps = 0;
	prepare_channel_timestamps_to_send(3, attr_CH3_Timestamps_read, &nTimestamps);
	//	Set the attribute value
	attr.set_value(attr_CH3_Timestamps_read, nTimestamps);
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::read_CH3_Timestamps
}

//--------------------------------------------------------
/**
 *	Method      : XTDC4::add_dynamic_attributes()
 *	Description : Create the dynamic attributes if any
 *                for specified device.
 */
//--------------------------------------------------------
void XTDC4::add_dynamic_attributes()
{
	/*----- PROTECTED REGION ID(XTDC4::add_dynamic_attributes) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic attributes if any
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::add_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Command Start related method
 *	Description: Starts collecting data. Will fill the DMA memory until stop is called.
 *
 */
//--------------------------------------------------------
void XTDC4::start()
{
	DEBUG_STREAM << "XTDC4::Start()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(XTDC4::start) ENABLED START -----*/
	if (attr_config_changed_read) // apply config before start if changed
	{
		apply_config();
	}

	// reset counters
	attr_last_run_valid_starts_read[0] = 0;
	attr_last_run_empty_starts_read[0] = 0;
	attr_last_run_hits_read[0] = 0;
	attr_last_run_start_errors_read[0] = 0;

	first_start_timestamp = -1;
	
	xtdc4_start_tiger(this_device_ref);
	xtdc4_start_capture(this_device_ref);
	

	set_state(Tango::DevState::RUNNING);
	run_poller_thread();
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::start
}
//--------------------------------------------------------
/**
 *	Command Stop related method
 *	Description: Stops collecting data
 *
 */
//--------------------------------------------------------
void XTDC4::stop()
{
	DEBUG_STREAM << "XTDC4::Stop()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(XTDC4::stop) ENABLED START -----*/
	xtdc4_pause_capture(this_device_ref); // pause capture and wait until all data are read by polling thread
	xtdc4_stop_tiger(this_device_ref);

	set_state(Tango::DevState::STANDBY); //state is changed to ON by polling thread
	//packet_parser will stop automatically if state is not RUNNING and it runs out of data to parse
	/*----- PROTECTED REGION END -----*/	//	XTDC4::stop
}
//--------------------------------------------------------
/**
 *	Command Off related method
 *	Description: Releases the xTDC4, for example to be used locally. To regain it back, call Init
 *
 */
//--------------------------------------------------------
void XTDC4::off()
{
	DEBUG_STREAM << "XTDC4::Off()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(XTDC4::off) ENABLED START -----*/
	
	xtdc4_close(this_device_ref);
	set_state(Tango::DevState::OFF);
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::off
}
//--------------------------------------------------------
/**
 *	Command apply_config related method
 *	Description: 
 *
 */
//--------------------------------------------------------
void XTDC4::apply_config()
{
	DEBUG_STREAM << "XTDC4::apply_config()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(XTDC4::apply_config) ENABLED START -----*/

	// prepare configuration
	xtdc4_configuration config;
	// fill configuration data structure with default values
	// so that the configuration is valid and only parameters
	// of interest have to be set explicitly
	xtdc4_get_default_configuration(this_device_ref, &config);

	// reset TDC time counter on respective edge of start pulse
	config.start_rising = attr_START_RISING_read[0];
	config.dc_offset[0] = attr_START_DC_OFFSET_read[0]; // DC offset[0] is start, [1] is ch0, etc

	config.channel[0].enabled = attr_CH0_ENABLED_read[0];
	config.channel[0].rising = attr_CH0_RISING_read[0];
	config.channel[0].start = attr_TW_START_read[0];
	config.channel[0].stop = attr_TW_END_read[0];
	config.dc_offset[1] = attr_CH0_DC_OFFSET_read[0];

	config.channel[1].enabled = attr_CH1_ENABLED_read[0];
	config.channel[1].rising = attr_CH1_RISING_read[0];
	config.channel[1].start = attr_TW_START_read[0];
	config.channel[1].stop = attr_TW_END_read[0];
	config.dc_offset[2] = attr_CH1_DC_OFFSET_read[0];

	config.channel[2].enabled = attr_CH2_ENABLED_read[0];
	config.channel[2].rising = attr_CH2_RISING_read[0];
	config.channel[2].start = attr_TW_START_read[0];
	config.channel[2].stop = attr_TW_END_read[0];
	config.dc_offset[3] = attr_CH2_DC_OFFSET_read[0];

	config.channel[3].enabled = attr_CH3_ENABLED_read[0];
	config.channel[3].rising = attr_CH3_RISING_read[0];
	config.channel[3].start = attr_TW_START_read[0];
	config.channel[3].stop = attr_TW_END_read[0];
	config.dc_offset[4] = attr_CH3_DC_OFFSET_read[0];

	for (int i = 1; i < XTDC4_TDC_CHANNEL_COUNT + 1; i++) // config.trigger[0] is for start, [1] is ch0, etc
	{
		// enable timestamp generation on the respective edge for all channel triggers
		config.trigger[i].rising = config.channel[i-1].rising ? 1 : 0;
		config.trigger[i].falling = config.channel[i-1].rising ? 0 : 1;
	}
	config.trigger[0].rising = config.start_rising ? 1 : 0;
	config.trigger[0].falling = config.start_rising ? 0 : 1;


	
	double start_trigger_generator_period = 1.0 / attr_start_trigger_generator_frequency_read[0];
	// 750 = 200 kHz
	// 75000 = 2 kHz
	config.auto_trigger_period = (int)floor(start_trigger_generator_period * 150000000);
	config.auto_trigger_random_exponent = 0;

	// setup TiGeR
	// sending a signal to the LEMO outputs (and to the TDC on the same channel)
	// requires proper 50 Ohm termination on the LEMO output to work reliably

	// use auto trigger to generate
	// a signal with 13.2 ns pulse width on LEMO output Start
	config.tiger_block[0].enable = attr_start_trigger_generator_read[0] ? 1 : 0;
	config.tiger_block[0].start = 0;
	config.tiger_block[0].stop = 1;
	config.tiger_block[0].negate = 0;
	config.tiger_block[0].retrigger = 0;
	config.tiger_block[0].extend = 0;
	config.tiger_block[0].enable_lemo_output = attr_start_trigger_generator_read[0] ? 1 : 0;
	config.tiger_block[0].sources = XTDC4_TRIGGER_SOURCE_AUTO;

	//set timeout (it is not controlled by hardware)
	run_timeout_ticks = (__int64) (attr_run_timeout_read[0] * 600e6); //1 tick = 1.6666666666 ns (600 MHz)
	// activate configuration
	int error_code = xtdc4_configure(this_device_ref, &config);
	if (error_code != CRONO_OK)
	{
		attr_error_code_read[0] = error_code;
		strcpy_s(attr_error_message_read[0], 255, xtdc4_get_last_error_message(this_device_ref));
		set_state(Tango::DevState::FAULT);
	}
	else
	{
		attr_config_changed_read[0] = 0;
	}
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::apply_config
}
//--------------------------------------------------------
/**
 *	Command Clear related method
 *	Description: Clear all timestamps in buffer.
 *
 */
//--------------------------------------------------------
void XTDC4::clear()
{
	DEBUG_STREAM << "XTDC4::Clear()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(XTDC4::clear) ENABLED START -----*/
	
	// empty the data queue
	for (int ctr = 0; ctr < NUMBER_OF_EXPOSED_CHANNELS; ctr++)
	{
		while (!datachunk_list[ctr].empty())
		{
			datachunk * elem = datachunk_list[ctr].front();
			datachunk_list[ctr].pop(); // this deletes the pointer to datachunk from queue
			elem->clear();
			delete elem; // this should delete the datachunk itself
		}
	}
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::clear
}
//--------------------------------------------------------
/**
 *	Method      : XTDC4::add_dynamic_commands()
 *	Description : Create the dynamic commands if any
 *                for specified device.
 */
//--------------------------------------------------------
void XTDC4::add_dynamic_commands()
{
	/*----- PROTECTED REGION ID(XTDC4::add_dynamic_commands) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic commands if any
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4::add_dynamic_commands
}

/*----- PROTECTED REGION ID(XTDC4::namespace_ending) ENABLED START -----*/
//	Additional Methods

void XTDC4::run_poller_thread()
{
	std::thread poller_thread = std::thread(&XTDC4::poller_thread, this);
	poller_thread_ref = & poller_thread;
	poller_thread.detach();
}

void XTDC4::poller_thread()
{
#ifdef _DEBUG
	std::cout << "Thread launched" << std::endl;
#endif

	xtdc4_read_in read_config;
	// automatically acknowledge all data as processed
	// on the next call to xtdc4_read()
	// old packet pointers are invalid after calling xtdc4_read()
	read_config.acknowledge_last_read = 1;
	// structure with packet pointers for read data
	xtdc4_read_out read_data;

	while (true) // run the polling loop
	{
		if (bTerminatePolingThread) // got a terminate request
		{
			bTerminatePolingThread = 0;
#ifdef _DEBUG
			std::cout << "Thread terminated" << std::endl;
#endif
			set_state(Tango::DevState::ON);			
			return;
		}
		int status = xtdc4_read(this_device_ref, &read_config, &read_data);
		switch (status)
		{
		case (CRONO_READ_NO_DATA) :
		{
			// no data read.
			if (state() == Tango::DevState::STANDBY)
			{ // acquisition is stopped and no more data available. Job done!
				xtdc4_stop_capture(this_device_ref);
				set_state(Tango::DevState::ON);
#ifdef _DEBUG
				std::cout << "Thread stopped" << std::endl;
#endif
				return;
			}
		}break;
		case(CRONO_READ_INTERNAL_ERROR) :
		{
			attr_error_code_read[0] = CRONO_INTERNAL_ERROR;
			strcpy_s(attr_error_message_read[0], 255, xtdc4_get_last_error_message(this_device_ref));
			set_state(Tango::DevState::FAULT);
			return;
		}break;
		case(CRONO_READ_OK) :
		{
			unsigned char package_error_flags_mask = 0x3E;	// TODO:
			unsigned char hit_error_flags_mask = 0xC0;		// These parameters should not be hardcoded?
						
			crono_packet **first_packet = &read_data.first_packet;
			crono_packet **last_packet = &read_data.last_packet;

			//check the length of data read
			if ((last_packet - first_packet) > 16000000) // this is an insurance against something bad happening in memory, like first_packet>last_packet.
														//There should be otherwise no conceivable way to get anywhere close to 2M hits (8 bytes each) per 100 ms polling period
			{
				xtdc4_stop_capture(this_device_ref);				
#ifdef _DEBUG
				std::cout << "Thread failed" << std::endl;
#endif
				set_state(Tango::DevState::FAULT);
				return;
			}

			datachunk * current_chunk_array[NUMBER_OF_EXPOSED_CHANNELS]; // an array of pointers to datachunks.  The array is local.
			// the datachunks themselves are dynamically allocated and need to be destroyed upon copying to the output array.
			for (int ctr = 0; ctr < NUMBER_OF_EXPOSED_CHANNELS; ctr++)
			{
				current_chunk_array[ctr] = new datachunk(); // initialize chunks dynamically. 
			}

			// iterate over all packets from first to last
			while ((*first_packet) <= (*last_packet))
			{
				int bPacketInvalid = 0;
				crono_packet *p = *first_packet;
				if (first_start_timestamp == -1)
				{
					first_start_timestamp = p->timestamp;
				}
				// check start tmestamp and see if timeout is due
				if ((p->timestamp > (run_timeout_ticks + first_start_timestamp)) && (run_timeout_ticks > 0))
				{
					xtdc4_stop_capture(this_device_ref);
					push_datachunks(current_chunk_array);
#ifdef _DEBUG
					std::cout << "Thread timeout" << std::endl;
#endif
					set_state(Tango::DevState::ON);
					return; 
				}
				// a packet with no hits
				if (p->length == 0)
				{
					(attr_last_run_empty_starts_read[0])++;
					bPacketInvalid = 1;
				}
				// a packet with errors
				if (p->flags&(package_error_flags_mask))
				{
					(attr_last_run_start_errors_read[0])++;
					bPacketInvalid = 1;
				}

				if (!bPacketInvalid)
				{
					int hitcount = 2 * (p->length);
					if ((p->flags & 0x1) == 1)
						hitcount -= 1;
					//if (hitcount > maxhits)
					//	return XTDC4_WRAPPER_BUFFER_TOO_SMALL; // current 
					//if (hitcount > maxhits - *number_of_hits)
					//	return XTDC4_WRAPPER_BUFFER_FULL;
					unsigned long *packetdata = (unsigned long*)(p->data);
					//check individual hits for errors
					if ((hit_error_flags_mask)& 0xf0)
					{
						for (int ctr = 0; ctr < hitcount; ctr++)
						{
							if (packetdata[ctr] & ((unsigned long)(hit_error_flags_mask) & (unsigned long)0xf0))
							{
								(attr_last_run_start_errors_read[0])++; // if one hit is invalid, the whole start package is invalidated
								bPacketInvalid = 1;
								break;
							}

						}
					}

					if (!bPacketInvalid) // if the packet is valid, copy it to the output
					{
						unsigned long rollover_count = 0;
						int realhitcount = 0;
						for (int ctr = 0; ctr < hitcount; ctr++)
						{
							
								
							if ((packetdata[ctr] & (unsigned long)0x2f) == 0x2f)// in the last byte, bit 5 is rollover and bits 0..3 indicate channel 15
							{
								rollover_count += 0x01000000;
							}
							else
							{
								unsigned char channel=(unsigned char)(packetdata[ctr] & 0x0f);
								current_chunk_array[channel]->push_back((packetdata[ctr] >> 8) + rollover_count);												
								realhitcount++; // not a rollover event
							}
						}
						if (realhitcount)
						{
							(attr_last_run_valid_starts_read[0])++;
							attr_last_run_hits_read[0] = attr_last_run_hits_read[0] + realhitcount;// update number of hits to be returned				
						}
						else
						{
							(attr_last_run_empty_starts_read[0])++; // package contained only rollover events
						}

					}
				}
				// go to next packet
				*first_packet = crono_next_packet(*first_packet);
			}
			// datachunks have been formed. Now we need to push them into queues
			push_datachunks(current_chunk_array);

			//for (int ctr = 0; ctr < NUMBER_OF_EXPOSED_CHANNELS; ctr++)//
			//{
			//	if (current_chunk_array[ctr]->size() != 0)
			//	{
			//		//std::cout << current_chunk_array[ctr]->size() << std::endl;
			//		//std::cout << current_chunk_array[ctr]->max_size() << std::endl;
			//		datachunk_list[ctr].push(current_chunk_array[ctr]); // a pointer to dynamically created datachunk is pushed into a queue of pointers. 
			//	}
			//	else
			//	{
			//		// empty chunk - delete it! the pointer will be discarded as it is in a local array
			//		delete current_chunk_array[ctr];
			//	}
			//}			
		}break;
		}//switch
		Sleep(100);
	}
	return;
}

void XTDC4::prepare_channel_timestamps_to_send(unsigned char channel, Tango::DevULong64 *attr_CH_Timestamps_read, unsigned long * number_of_timestamps_prepared)
{
	*number_of_timestamps_prepared = 0;
	while (!datachunk_list[channel].empty())
	{
		//std::cout << datachunk_list[channel].front() -> size() << endl;
		//if (datachunk_list_lock[channel])//the queue is being written. Wait a bit and repeat.
		//{									
		//	Sleep(1);
		//	continue;
		//}
		if ((datachunk_list[channel].size() < 2) && state() != Tango::DevState::ON) // never read last element unless acquisition is ended. Thus no racing conditions.
		{
			break;
		}
		datachunk * chunk = datachunk_list[channel].front();
		if (chunk->size() + *number_of_timestamps_prepared >= MAX_TIMESTAMPS_BUFFER_SIZE)
		{
			break; // output buffer full, next chunk does not fit. Wait until next time
		}

		datachunk_list[channel].pop(); // this deletes the pointer to datachunk from the queue
		// but the chunk itself still exist; copy it to the output

		std::copy_n(&((*chunk)[0]), chunk->size(), attr_CH_Timestamps_read + *number_of_timestamps_prepared);
		*number_of_timestamps_prepared += chunk->size();

		chunk->clear();
		delete chunk; // this should delete the datachunk itself
	}
	//std::cout << *number_of_timestamps_prepared << endl;
}
void XTDC4::push_datachunks(datachunk * current_chunk_array[NUMBER_OF_EXPOSED_CHANNELS])
{
	for (int ctr = 0; ctr < NUMBER_OF_EXPOSED_CHANNELS; ctr++)
	{
		if (current_chunk_array[ctr]->size() != 0)
		{
			//std::cout << current_chunk_array[ctr]->size() << std::endl;
			//std::cout << current_chunk_array[ctr]->max_size() << std::endl;
			datachunk_list[ctr].push(current_chunk_array[ctr]); // a pointer to dynamically created datachunk is pushed into a queue of pointers. 
		}
		else
		{
			// empty chunk - delete it! the pointer will be discarded as it is in a local array
			delete current_chunk_array[ctr];
		}
	}
}

/*----- PROTECTED REGION END -----*/	//	XTDC4::namespace_ending
} //	namespace
