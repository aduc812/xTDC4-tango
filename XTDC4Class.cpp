/*----- PROTECTED REGION ID(XTDC4Class.cpp) ENABLED START -----*/
static const char *RcsId      = "$Id:  $";
static const char *TagName    = "$Name:  $";
static const char *CvsPath    = "$Source:  $";
static const char *SvnPath    = "$HeadURL:  $";
static const char *HttpServer = "http://www.esrf.eu/computing/cs/tango/tango_doc/ds_doc/";
//=============================================================================
//
// file :        XTDC4Class.cpp
//
// description : C++ source for the XTDC4Class.
//               A singleton class derived from DeviceClass.
//               It implements the command and attribute list
//               and all properties and methods required
//               by the XTDC4 once per process.
//
// project :     xTDC4_DevServer
//
// This file is part of Tango device class.
// 
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
// 
// $Author:  $
//
// $Revision:  $
// $Date:  $
//
// $HeadURL:  $
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <XTDC4Class.h>

/*----- PROTECTED REGION END -----*/	//	XTDC4Class.cpp

//-------------------------------------------------------------------
/**
 *	Create XTDC4Class singleton and
 *	return it in a C function for Python usage
 */
//-------------------------------------------------------------------
extern "C" {
#ifdef _TG_WINDOWS_

__declspec(dllexport)

#endif

	Tango::DeviceClass *_create_XTDC4_class(const char *name) {
		return XTDC4_ns::XTDC4Class::init(name);
	}
}

namespace XTDC4_ns
{
//===================================================================
//	Initialize pointer for singleton pattern
//===================================================================
XTDC4Class *XTDC4Class::_instance = NULL;

//--------------------------------------------------------
/**
 * method : 		XTDC4Class::XTDC4Class(string &s)
 * description : 	constructor for the XTDC4Class
 *
 * @param s	The class name
 */
//--------------------------------------------------------
XTDC4Class::XTDC4Class(string &s):Tango::DeviceClass(s)
{
	cout2 << "Entering XTDC4Class constructor" << endl;
	set_default_property();
	write_class_property();

	/*----- PROTECTED REGION ID(XTDC4Class::constructor) ENABLED START -----*/
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4Class::constructor

	cout2 << "Leaving XTDC4Class constructor" << endl;
}

//--------------------------------------------------------
/**
 * method : 		XTDC4Class::~XTDC4Class()
 * description : 	destructor for the XTDC4Class
 */
//--------------------------------------------------------
XTDC4Class::~XTDC4Class()
{
	/*----- PROTECTED REGION ID(XTDC4Class::destructor) ENABLED START -----*/
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4Class::destructor

	_instance = NULL;
}


//--------------------------------------------------------
/**
 * method : 		XTDC4Class::init
 * description : 	Create the object if not already done.
 *                  Otherwise, just return a pointer to the object
 *
 * @param	name	The class name
 */
//--------------------------------------------------------
XTDC4Class *XTDC4Class::init(const char *name)
{
	if (_instance == NULL)
	{
		try
		{
			string s(name);
			_instance = new XTDC4Class(s);
		}
		catch (bad_alloc &)
		{
			throw;
		}
	}
	return _instance;
}

//--------------------------------------------------------
/**
 * method : 		XTDC4Class::instance
 * description : 	Check if object already created,
 *                  and return a pointer to the object
 */
//--------------------------------------------------------
XTDC4Class *XTDC4Class::instance()
{
	if (_instance == NULL)
	{
		cerr << "Class is not initialised !!" << endl;
		exit(-1);
	}
	return _instance;
}



//===================================================================
//	Command execution method calls
//===================================================================
//--------------------------------------------------------
/**
 * method : 		StartClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *StartClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "StartClass::execute(): arrived" << endl;
	((static_cast<XTDC4 *>(device))->start());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		StopClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *StopClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "StopClass::execute(): arrived" << endl;
	((static_cast<XTDC4 *>(device))->stop());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		OffClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *OffClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "OffClass::execute(): arrived" << endl;
	((static_cast<XTDC4 *>(device))->off());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		apply_configClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *apply_configClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "apply_configClass::execute(): arrived" << endl;
	((static_cast<XTDC4 *>(device))->apply_config());
	return new CORBA::Any();
}


//===================================================================
//	Properties management
//===================================================================
//--------------------------------------------------------
/**
 *	Method      : XTDC4Class::get_class_property()
 *	Description : Get the class property for specified name.
 */
//--------------------------------------------------------
Tango::DbDatum XTDC4Class::get_class_property(string &prop_name)
{
	for (unsigned int i=0 ; i<cl_prop.size() ; i++)
		if (cl_prop[i].name == prop_name)
			return cl_prop[i];
	//	if not found, returns  an empty DbDatum
	return Tango::DbDatum(prop_name);
}

//--------------------------------------------------------
/**
 *	Method      : XTDC4Class::get_default_device_property()
 *	Description : Return the default value for device property.
 */
//--------------------------------------------------------
Tango::DbDatum XTDC4Class::get_default_device_property(string &prop_name)
{
	for (unsigned int i=0 ; i<dev_def_prop.size() ; i++)
		if (dev_def_prop[i].name == prop_name)
			return dev_def_prop[i];
	//	if not found, return  an empty DbDatum
	return Tango::DbDatum(prop_name);
}

//--------------------------------------------------------
/**
 *	Method      : XTDC4Class::get_default_class_property()
 *	Description : Return the default value for class property.
 */
//--------------------------------------------------------
Tango::DbDatum XTDC4Class::get_default_class_property(string &prop_name)
{
	for (unsigned int i=0 ; i<cl_def_prop.size() ; i++)
		if (cl_def_prop[i].name == prop_name)
			return cl_def_prop[i];
	//	if not found, return  an empty DbDatum
	return Tango::DbDatum(prop_name);
}


//--------------------------------------------------------
/**
 *	Method      : XTDC4Class::set_default_property()
 *	Description : Set default property (class and device) for wizard.
 *                For each property, add to wizard property name and description.
 *                If default value has been set, add it to wizard property and
 *                store it in a DbDatum.
 */
//--------------------------------------------------------
void XTDC4Class::set_default_property()
{
	string	prop_name;
	string	prop_desc;
	string	prop_def;
	vector<string>	vect_data;

	//	Set Default Class Properties

	//	Set Default device Properties
	prop_name = "buffer_size";
	prop_desc = "Amount of local memory used for DMA data buffer";
	prop_def  = "16777216";
	vect_data.clear();
	vect_data.push_back("16777216");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "board_id";
	prop_desc = "the global index in all cronologic devices.\nThis 8 bit number is filled into each packet created by the board and is useful if data streams\nof multiple boards will be merged. If only XTDC4 cards are used this number can be set to the\ncard index. If boards of different types that use a compatible data format are used in a system\neach board should get a unique id. Can be changed at runtime.";
	prop_def  = "0";
	vect_data.clear();
	vect_data.push_back("0");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "card_index";
	prop_desc = "The index in the list of XTDC4 boards that should be initialized.\nThere might be multiple boards in the system that are handled by this driver as reported by\nxtdc4_count_devices. This index selects one of them. Boards are enumerated depending on the\nPCIe slot. The lower the bus number and the lower the slot number the lower the card index.";
	prop_def  = "0";
	vect_data.clear();
	vect_data.push_back("0");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "use_ext_clock";
	prop_desc = "If set to 1 use external 10 MHz reference. If set to 0 use internal reference.";
	prop_def  = "0";
	vect_data.clear();
	vect_data.push_back("0");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
}

//--------------------------------------------------------
/**
 *	Method      : XTDC4Class::write_class_property()
 *	Description : Set class description fields as property in database
 */
//--------------------------------------------------------
void XTDC4Class::write_class_property()
{
	//	First time, check if database used
	if (Tango::Util::_UseDb == false)
		return;

	Tango::DbData	data;
	string	classname = get_name();
	string	header;
	string::size_type	start, end;

	//	Put title
	Tango::DbDatum	title("ProjectTitle");
	string	str_title("xTDC4_DevServer");
	title << str_title;
	data.push_back(title);

	//	Put Description
	Tango::DbDatum	description("Description");
	vector<string>	str_desc;
	str_desc.push_back("https://www.cronologic.de/time_measurement/tdc/xtdc4/");
	description << str_desc;
	data.push_back(description);

	//	put cvs or svn location
	string	filename("XTDC4");
	filename += "Class.cpp";

	// check for cvs information
	string	src_path(CvsPath);
	start = src_path.find("/");
	if (start!=string::npos)
	{
		end   = src_path.find(filename);
		if (end>start)
		{
			string	strloc = src_path.substr(start, end-start);
			//	Check if specific repository
			start = strloc.find("/cvsroot/");
			if (start!=string::npos && start>0)
			{
				string	repository = strloc.substr(0, start);
				if (repository.find("/segfs/")!=string::npos)
					strloc = "ESRF:" + strloc.substr(start, strloc.length()-start);
			}
			Tango::DbDatum	cvs_loc("cvs_location");
			cvs_loc << strloc;
			data.push_back(cvs_loc);
		}
	}

	// check for svn information
	else
	{
		string	src_path(SvnPath);
		start = src_path.find("://");
		if (start!=string::npos)
		{
			end = src_path.find(filename);
			if (end>start)
			{
				header = "$HeadURL: ";
				start = header.length();
				string	strloc = src_path.substr(start, (end-start));
				
				Tango::DbDatum	svn_loc("svn_location");
				svn_loc << strloc;
				data.push_back(svn_loc);
			}
		}
	}

	//	Get CVS or SVN revision tag
	
	// CVS tag
	string	tagname(TagName);
	header = "$Name: ";
	start = header.length();
	string	endstr(" $");
	
	end   = tagname.find(endstr);
	if (end!=string::npos && end>start)
	{
		string	strtag = tagname.substr(start, end-start);
		Tango::DbDatum	cvs_tag("cvs_tag");
		cvs_tag << strtag;
		data.push_back(cvs_tag);
	}
	
	// SVN tag
	string	svnpath(SvnPath);
	header = "$HeadURL: ";
	start = header.length();
	
	end   = svnpath.find(endstr);
	if (end!=string::npos && end>start)
	{
		string	strloc = svnpath.substr(start, end-start);
		
		string tagstr ("/tags/");
		start = strloc.find(tagstr);
		if ( start!=string::npos )
		{
			start = start + tagstr.length();
			end   = strloc.find(filename);
			string	strtag = strloc.substr(start, end-start-1);
			
			Tango::DbDatum	svn_tag("svn_tag");
			svn_tag << strtag;
			data.push_back(svn_tag);
		}
	}

	//	Get URL location
	string	httpServ(HttpServer);
	if (httpServ.length()>0)
	{
		Tango::DbDatum	db_doc_url("doc_url");
		db_doc_url << httpServ;
		data.push_back(db_doc_url);
	}

	//  Put inheritance
	Tango::DbDatum	inher_datum("InheritedFrom");
	vector<string> inheritance;
	inheritance.push_back("TANGO_BASE_CLASS");
	inher_datum << inheritance;
	data.push_back(inher_datum);

	//	Call database and and values
	get_db_class()->put_property(data);
}

//===================================================================
//	Factory methods
//===================================================================

//--------------------------------------------------------
/**
 *	Method      : XTDC4Class::device_factory()
 *	Description : Create the device object(s)
 *                and store them in the device list
 */
//--------------------------------------------------------
void XTDC4Class::device_factory(const Tango::DevVarStringArray *devlist_ptr)
{
	/*----- PROTECTED REGION ID(XTDC4Class::device_factory_before) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4Class::device_factory_before

	//	Create devices and add it into the device list
	for (unsigned long i=0 ; i<devlist_ptr->length() ; i++)
	{
		cout4 << "Device name : " << (*devlist_ptr)[i].in() << endl;
		device_list.push_back(new XTDC4(this, (*devlist_ptr)[i]));
	}

	//	Manage dynamic attributes if any
	erase_dynamic_attributes(devlist_ptr, get_class_attr()->get_attr_list());

	//	Export devices to the outside world
	for (unsigned long i=1 ; i<=devlist_ptr->length() ; i++)
	{
		//	Add dynamic attributes if any
		XTDC4 *dev = static_cast<XTDC4 *>(device_list[device_list.size()-i]);
		dev->add_dynamic_attributes();

		//	Check before if database used.
		if ((Tango::Util::_UseDb == true) && (Tango::Util::_FileDb == false))
			export_device(dev);
		else
			export_device(dev, dev->get_name().c_str());
	}

	/*----- PROTECTED REGION ID(XTDC4Class::device_factory_after) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4Class::device_factory_after
}
//--------------------------------------------------------
/**
 *	Method      : XTDC4Class::attribute_factory()
 *	Description : Create the attribute object(s)
 *                and store them in the attribute list
 */
//--------------------------------------------------------
void XTDC4Class::attribute_factory(vector<Tango::Attr *> &att_list)
{
	/*----- PROTECTED REGION ID(XTDC4Class::attribute_factory_before) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4Class::attribute_factory_before
	//	Attribute : error_code
	error_codeAttrib	*error_code = new error_codeAttrib();
	Tango::UserDefaultAttrProp	error_code_prop;
	//	description	not set for error_code
	//	label	not set for error_code
	//	unit	not set for error_code
	//	standard_unit	not set for error_code
	//	display_unit	not set for error_code
	//	format	not set for error_code
	//	max_value	not set for error_code
	//	min_value	not set for error_code
	//	max_alarm	not set for error_code
	//	min_alarm	not set for error_code
	//	max_warning	not set for error_code
	//	min_warning	not set for error_code
	//	delta_t	not set for error_code
	//	delta_val	not set for error_code
	
	error_code->set_default_properties(error_code_prop);
	//	Not Polled
	error_code->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(error_code);

	//	Attribute : error_message
	error_messageAttrib	*error_message = new error_messageAttrib();
	Tango::UserDefaultAttrProp	error_message_prop;
	//	description	not set for error_message
	//	label	not set for error_message
	//	unit	not set for error_message
	//	standard_unit	not set for error_message
	//	display_unit	not set for error_message
	//	format	not set for error_message
	//	max_value	not set for error_message
	//	min_value	not set for error_message
	//	max_alarm	not set for error_message
	//	min_alarm	not set for error_message
	//	max_warning	not set for error_message
	//	min_warning	not set for error_message
	//	delta_t	not set for error_message
	//	delta_val	not set for error_message
	
	error_message->set_default_properties(error_message_prop);
	//	Not Polled
	error_message->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(error_message);

	//	Attribute : device_type
	device_typeAttrib	*device_type = new device_typeAttrib();
	Tango::UserDefaultAttrProp	device_type_prop;
	device_type_prop.set_description("For xTDC4, the device type is 6");
	//	label	not set for device_type
	//	unit	not set for device_type
	//	standard_unit	not set for device_type
	//	display_unit	not set for device_type
	//	format	not set for device_type
	//	max_value	not set for device_type
	//	min_value	not set for device_type
	//	max_alarm	not set for device_type
	//	min_alarm	not set for device_type
	//	max_warning	not set for device_type
	//	min_warning	not set for device_type
	//	delta_t	not set for device_type
	//	delta_val	not set for device_type
	
	device_type->set_default_properties(device_type_prop);
	//	Not Polled
	device_type->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(device_type);

	//	Attribute : START_RISING
	START_RISINGAttrib	*start_rising = new START_RISINGAttrib();
	Tango::UserDefaultAttrProp	start_rising_prop;
	start_rising_prop.set_description("Trigger START on rising of falling edge");
	//	label	not set for START_RISING
	//	unit	not set for START_RISING
	//	standard_unit	not set for START_RISING
	//	display_unit	not set for START_RISING
	//	format	not set for START_RISING
	//	max_value	not set for START_RISING
	//	min_value	not set for START_RISING
	//	max_alarm	not set for START_RISING
	//	min_alarm	not set for START_RISING
	//	max_warning	not set for START_RISING
	//	min_warning	not set for START_RISING
	//	delta_t	not set for START_RISING
	//	delta_val	not set for START_RISING
	
	start_rising->set_default_properties(start_rising_prop);
	//	Not Polled
	start_rising->set_disp_level(Tango::OPERATOR);
	start_rising->set_memorized();
	start_rising->set_memorized_init(true);
	att_list.push_back(start_rising);

	//	Attribute : START_DC_OFFSET
	START_DC_OFFSETAttrib	*start_dc_offset = new START_DC_OFFSETAttrib();
	Tango::UserDefaultAttrProp	start_dc_offset_prop;
	start_dc_offset_prop.set_description("DC threshold of START input");
	//	label	not set for START_DC_OFFSET
	start_dc_offset_prop.set_unit("V");
	//	standard_unit	not set for START_DC_OFFSET
	//	display_unit	not set for START_DC_OFFSET
	//	format	not set for START_DC_OFFSET
	start_dc_offset_prop.set_max_value("1.18");
	start_dc_offset_prop.set_min_value("-1.32");
	//	max_alarm	not set for START_DC_OFFSET
	//	min_alarm	not set for START_DC_OFFSET
	//	max_warning	not set for START_DC_OFFSET
	//	min_warning	not set for START_DC_OFFSET
	//	delta_t	not set for START_DC_OFFSET
	//	delta_val	not set for START_DC_OFFSET
	
	start_dc_offset->set_default_properties(start_dc_offset_prop);
	//	Not Polled
	start_dc_offset->set_disp_level(Tango::OPERATOR);
	start_dc_offset->set_memorized();
	start_dc_offset->set_memorized_init(true);
	att_list.push_back(start_dc_offset);

	//	Attribute : CH0_ENABLED
	CH0_ENABLEDAttrib	*ch0_enabled = new CH0_ENABLEDAttrib();
	Tango::UserDefaultAttrProp	ch0_enabled_prop;
	ch0_enabled_prop.set_description("Enable input");
	//	label	not set for CH0_ENABLED
	//	unit	not set for CH0_ENABLED
	//	standard_unit	not set for CH0_ENABLED
	//	display_unit	not set for CH0_ENABLED
	//	format	not set for CH0_ENABLED
	//	max_value	not set for CH0_ENABLED
	//	min_value	not set for CH0_ENABLED
	//	max_alarm	not set for CH0_ENABLED
	//	min_alarm	not set for CH0_ENABLED
	//	max_warning	not set for CH0_ENABLED
	//	min_warning	not set for CH0_ENABLED
	//	delta_t	not set for CH0_ENABLED
	//	delta_val	not set for CH0_ENABLED
	
	ch0_enabled->set_default_properties(ch0_enabled_prop);
	//	Not Polled
	ch0_enabled->set_disp_level(Tango::OPERATOR);
	ch0_enabled->set_memorized();
	ch0_enabled->set_memorized_init(true);
	att_list.push_back(ch0_enabled);

	//	Attribute : CH0_RISING
	CH0_RISINGAttrib	*ch0_rising = new CH0_RISINGAttrib();
	Tango::UserDefaultAttrProp	ch0_rising_prop;
	ch0_rising_prop.set_description("Trigger input on rising of falling edge");
	//	label	not set for CH0_RISING
	//	unit	not set for CH0_RISING
	//	standard_unit	not set for CH0_RISING
	//	display_unit	not set for CH0_RISING
	//	format	not set for CH0_RISING
	//	max_value	not set for CH0_RISING
	//	min_value	not set for CH0_RISING
	//	max_alarm	not set for CH0_RISING
	//	min_alarm	not set for CH0_RISING
	//	max_warning	not set for CH0_RISING
	//	min_warning	not set for CH0_RISING
	//	delta_t	not set for CH0_RISING
	//	delta_val	not set for CH0_RISING
	
	ch0_rising->set_default_properties(ch0_rising_prop);
	//	Not Polled
	ch0_rising->set_disp_level(Tango::OPERATOR);
	ch0_rising->set_memorized();
	ch0_rising->set_memorized_init(true);
	att_list.push_back(ch0_rising);

	//	Attribute : CH0_DC_OFFSET
	CH0_DC_OFFSETAttrib	*ch0_dc_offset = new CH0_DC_OFFSETAttrib();
	Tango::UserDefaultAttrProp	ch0_dc_offset_prop;
	ch0_dc_offset_prop.set_description("DC threshold of input");
	//	label	not set for CH0_DC_OFFSET
	ch0_dc_offset_prop.set_unit("V");
	//	standard_unit	not set for CH0_DC_OFFSET
	//	display_unit	not set for CH0_DC_OFFSET
	//	format	not set for CH0_DC_OFFSET
	ch0_dc_offset_prop.set_max_value("1.18");
	ch0_dc_offset_prop.set_min_value("-1.32");
	//	max_alarm	not set for CH0_DC_OFFSET
	//	min_alarm	not set for CH0_DC_OFFSET
	//	max_warning	not set for CH0_DC_OFFSET
	//	min_warning	not set for CH0_DC_OFFSET
	//	delta_t	not set for CH0_DC_OFFSET
	//	delta_val	not set for CH0_DC_OFFSET
	
	ch0_dc_offset->set_default_properties(ch0_dc_offset_prop);
	//	Not Polled
	ch0_dc_offset->set_disp_level(Tango::OPERATOR);
	ch0_dc_offset->set_memorized();
	ch0_dc_offset->set_memorized_init(true);
	att_list.push_back(ch0_dc_offset);

	//	Attribute : CH1_ENABLED
	CH1_ENABLEDAttrib	*ch1_enabled = new CH1_ENABLEDAttrib();
	Tango::UserDefaultAttrProp	ch1_enabled_prop;
	ch1_enabled_prop.set_description("Enable input");
	//	label	not set for CH1_ENABLED
	//	unit	not set for CH1_ENABLED
	//	standard_unit	not set for CH1_ENABLED
	//	display_unit	not set for CH1_ENABLED
	//	format	not set for CH1_ENABLED
	//	max_value	not set for CH1_ENABLED
	//	min_value	not set for CH1_ENABLED
	//	max_alarm	not set for CH1_ENABLED
	//	min_alarm	not set for CH1_ENABLED
	//	max_warning	not set for CH1_ENABLED
	//	min_warning	not set for CH1_ENABLED
	//	delta_t	not set for CH1_ENABLED
	//	delta_val	not set for CH1_ENABLED
	
	ch1_enabled->set_default_properties(ch1_enabled_prop);
	//	Not Polled
	ch1_enabled->set_disp_level(Tango::OPERATOR);
	ch1_enabled->set_memorized();
	ch1_enabled->set_memorized_init(true);
	att_list.push_back(ch1_enabled);

	//	Attribute : CH1_RISING
	CH1_RISINGAttrib	*ch1_rising = new CH1_RISINGAttrib();
	Tango::UserDefaultAttrProp	ch1_rising_prop;
	ch1_rising_prop.set_description("Trigger input on rising of falling edge");
	//	label	not set for CH1_RISING
	//	unit	not set for CH1_RISING
	//	standard_unit	not set for CH1_RISING
	//	display_unit	not set for CH1_RISING
	//	format	not set for CH1_RISING
	//	max_value	not set for CH1_RISING
	//	min_value	not set for CH1_RISING
	//	max_alarm	not set for CH1_RISING
	//	min_alarm	not set for CH1_RISING
	//	max_warning	not set for CH1_RISING
	//	min_warning	not set for CH1_RISING
	//	delta_t	not set for CH1_RISING
	//	delta_val	not set for CH1_RISING
	
	ch1_rising->set_default_properties(ch1_rising_prop);
	//	Not Polled
	ch1_rising->set_disp_level(Tango::OPERATOR);
	ch1_rising->set_memorized();
	ch1_rising->set_memorized_init(true);
	att_list.push_back(ch1_rising);

	//	Attribute : CH1_DC_OFFSET
	CH1_DC_OFFSETAttrib	*ch1_dc_offset = new CH1_DC_OFFSETAttrib();
	Tango::UserDefaultAttrProp	ch1_dc_offset_prop;
	ch1_dc_offset_prop.set_description("DC threshold of input");
	//	label	not set for CH1_DC_OFFSET
	ch1_dc_offset_prop.set_unit("V");
	//	standard_unit	not set for CH1_DC_OFFSET
	//	display_unit	not set for CH1_DC_OFFSET
	//	format	not set for CH1_DC_OFFSET
	ch1_dc_offset_prop.set_max_value("1.18");
	ch1_dc_offset_prop.set_min_value("-1.32");
	//	max_alarm	not set for CH1_DC_OFFSET
	//	min_alarm	not set for CH1_DC_OFFSET
	//	max_warning	not set for CH1_DC_OFFSET
	//	min_warning	not set for CH1_DC_OFFSET
	//	delta_t	not set for CH1_DC_OFFSET
	//	delta_val	not set for CH1_DC_OFFSET
	
	ch1_dc_offset->set_default_properties(ch1_dc_offset_prop);
	//	Not Polled
	ch1_dc_offset->set_disp_level(Tango::OPERATOR);
	ch1_dc_offset->set_memorized();
	ch1_dc_offset->set_memorized_init(true);
	att_list.push_back(ch1_dc_offset);

	//	Attribute : CH2_ENABLED
	CH2_ENABLEDAttrib	*ch2_enabled = new CH2_ENABLEDAttrib();
	Tango::UserDefaultAttrProp	ch2_enabled_prop;
	ch2_enabled_prop.set_description("Enable input");
	//	label	not set for CH2_ENABLED
	//	unit	not set for CH2_ENABLED
	//	standard_unit	not set for CH2_ENABLED
	//	display_unit	not set for CH2_ENABLED
	//	format	not set for CH2_ENABLED
	//	max_value	not set for CH2_ENABLED
	//	min_value	not set for CH2_ENABLED
	//	max_alarm	not set for CH2_ENABLED
	//	min_alarm	not set for CH2_ENABLED
	//	max_warning	not set for CH2_ENABLED
	//	min_warning	not set for CH2_ENABLED
	//	delta_t	not set for CH2_ENABLED
	//	delta_val	not set for CH2_ENABLED
	
	ch2_enabled->set_default_properties(ch2_enabled_prop);
	//	Not Polled
	ch2_enabled->set_disp_level(Tango::OPERATOR);
	ch2_enabled->set_memorized();
	ch2_enabled->set_memorized_init(true);
	att_list.push_back(ch2_enabled);

	//	Attribute : CH2_RISING
	CH2_RISINGAttrib	*ch2_rising = new CH2_RISINGAttrib();
	Tango::UserDefaultAttrProp	ch2_rising_prop;
	ch2_rising_prop.set_description("Trigger input on rising of falling edge");
	//	label	not set for CH2_RISING
	//	unit	not set for CH2_RISING
	//	standard_unit	not set for CH2_RISING
	//	display_unit	not set for CH2_RISING
	//	format	not set for CH2_RISING
	//	max_value	not set for CH2_RISING
	//	min_value	not set for CH2_RISING
	//	max_alarm	not set for CH2_RISING
	//	min_alarm	not set for CH2_RISING
	//	max_warning	not set for CH2_RISING
	//	min_warning	not set for CH2_RISING
	//	delta_t	not set for CH2_RISING
	//	delta_val	not set for CH2_RISING
	
	ch2_rising->set_default_properties(ch2_rising_prop);
	//	Not Polled
	ch2_rising->set_disp_level(Tango::OPERATOR);
	ch2_rising->set_memorized();
	ch2_rising->set_memorized_init(true);
	att_list.push_back(ch2_rising);

	//	Attribute : CH2_DC_OFFSET
	CH2_DC_OFFSETAttrib	*ch2_dc_offset = new CH2_DC_OFFSETAttrib();
	Tango::UserDefaultAttrProp	ch2_dc_offset_prop;
	ch2_dc_offset_prop.set_description("DC threshold of input");
	//	label	not set for CH2_DC_OFFSET
	ch2_dc_offset_prop.set_unit("V");
	//	standard_unit	not set for CH2_DC_OFFSET
	//	display_unit	not set for CH2_DC_OFFSET
	//	format	not set for CH2_DC_OFFSET
	ch2_dc_offset_prop.set_max_value("1.18");
	ch2_dc_offset_prop.set_min_value("-1.32");
	//	max_alarm	not set for CH2_DC_OFFSET
	//	min_alarm	not set for CH2_DC_OFFSET
	//	max_warning	not set for CH2_DC_OFFSET
	//	min_warning	not set for CH2_DC_OFFSET
	//	delta_t	not set for CH2_DC_OFFSET
	//	delta_val	not set for CH2_DC_OFFSET
	
	ch2_dc_offset->set_default_properties(ch2_dc_offset_prop);
	//	Not Polled
	ch2_dc_offset->set_disp_level(Tango::OPERATOR);
	ch2_dc_offset->set_memorized();
	ch2_dc_offset->set_memorized_init(true);
	att_list.push_back(ch2_dc_offset);

	//	Attribute : CH3_ENABLED
	CH3_ENABLEDAttrib	*ch3_enabled = new CH3_ENABLEDAttrib();
	Tango::UserDefaultAttrProp	ch3_enabled_prop;
	ch3_enabled_prop.set_description("Enable input");
	//	label	not set for CH3_ENABLED
	//	unit	not set for CH3_ENABLED
	//	standard_unit	not set for CH3_ENABLED
	//	display_unit	not set for CH3_ENABLED
	//	format	not set for CH3_ENABLED
	//	max_value	not set for CH3_ENABLED
	//	min_value	not set for CH3_ENABLED
	//	max_alarm	not set for CH3_ENABLED
	//	min_alarm	not set for CH3_ENABLED
	//	max_warning	not set for CH3_ENABLED
	//	min_warning	not set for CH3_ENABLED
	//	delta_t	not set for CH3_ENABLED
	//	delta_val	not set for CH3_ENABLED
	
	ch3_enabled->set_default_properties(ch3_enabled_prop);
	//	Not Polled
	ch3_enabled->set_disp_level(Tango::OPERATOR);
	ch3_enabled->set_memorized();
	ch3_enabled->set_memorized_init(true);
	att_list.push_back(ch3_enabled);

	//	Attribute : CH3_RISING
	CH3_RISINGAttrib	*ch3_rising = new CH3_RISINGAttrib();
	Tango::UserDefaultAttrProp	ch3_rising_prop;
	ch3_rising_prop.set_description("Trigger input on rising of falling edge");
	//	label	not set for CH3_RISING
	//	unit	not set for CH3_RISING
	//	standard_unit	not set for CH3_RISING
	//	display_unit	not set for CH3_RISING
	//	format	not set for CH3_RISING
	//	max_value	not set for CH3_RISING
	//	min_value	not set for CH3_RISING
	//	max_alarm	not set for CH3_RISING
	//	min_alarm	not set for CH3_RISING
	//	max_warning	not set for CH3_RISING
	//	min_warning	not set for CH3_RISING
	//	delta_t	not set for CH3_RISING
	//	delta_val	not set for CH3_RISING
	
	ch3_rising->set_default_properties(ch3_rising_prop);
	//	Not Polled
	ch3_rising->set_disp_level(Tango::OPERATOR);
	ch3_rising->set_memorized();
	ch3_rising->set_memorized_init(true);
	att_list.push_back(ch3_rising);

	//	Attribute : CH3_DC_OFFSET
	CH3_DC_OFFSETAttrib	*ch3_dc_offset = new CH3_DC_OFFSETAttrib();
	Tango::UserDefaultAttrProp	ch3_dc_offset_prop;
	ch3_dc_offset_prop.set_description("DC threshold of input");
	//	label	not set for CH3_DC_OFFSET
	ch3_dc_offset_prop.set_unit("V");
	//	standard_unit	not set for CH3_DC_OFFSET
	//	display_unit	not set for CH3_DC_OFFSET
	//	format	not set for CH3_DC_OFFSET
	ch3_dc_offset_prop.set_max_value("1.18");
	ch3_dc_offset_prop.set_min_value("-1.32");
	//	max_alarm	not set for CH3_DC_OFFSET
	//	min_alarm	not set for CH3_DC_OFFSET
	//	max_warning	not set for CH3_DC_OFFSET
	//	min_warning	not set for CH3_DC_OFFSET
	//	delta_t	not set for CH3_DC_OFFSET
	//	delta_val	not set for CH3_DC_OFFSET
	
	ch3_dc_offset->set_default_properties(ch3_dc_offset_prop);
	//	Not Polled
	ch3_dc_offset->set_disp_level(Tango::OPERATOR);
	ch3_dc_offset->set_memorized();
	ch3_dc_offset->set_memorized_init(true);
	att_list.push_back(ch3_dc_offset);

	//	Attribute : TW_START
	TW_STARTAttrib	*tw_start = new TW_STARTAttrib();
	Tango::UserDefaultAttrProp	tw_start_prop;
	tw_start_prop.set_description("Timestamps smaller than TW_START will not be recorded");
	//	label	not set for TW_START
	//	unit	not set for TW_START
	//	standard_unit	not set for TW_START
	//	display_unit	not set for TW_START
	//	format	not set for TW_START
	//	max_value	not set for TW_START
	//	min_value	not set for TW_START
	//	max_alarm	not set for TW_START
	//	min_alarm	not set for TW_START
	//	max_warning	not set for TW_START
	//	min_warning	not set for TW_START
	//	delta_t	not set for TW_START
	//	delta_val	not set for TW_START
	
	tw_start->set_default_properties(tw_start_prop);
	//	Not Polled
	tw_start->set_disp_level(Tango::OPERATOR);
	tw_start->set_memorized();
	tw_start->set_memorized_init(true);
	att_list.push_back(tw_start);

	//	Attribute : TW_END
	TW_ENDAttrib	*tw_end = new TW_ENDAttrib();
	Tango::UserDefaultAttrProp	tw_end_prop;
	tw_end_prop.set_description("Timestamps larger than TW_END will not be recorded");
	//	label	not set for TW_END
	//	unit	not set for TW_END
	//	standard_unit	not set for TW_END
	//	display_unit	not set for TW_END
	//	format	not set for TW_END
	tw_end_prop.set_max_value("268435456");
	tw_end_prop.set_min_value("0");
	//	max_alarm	not set for TW_END
	//	min_alarm	not set for TW_END
	//	max_warning	not set for TW_END
	//	min_warning	not set for TW_END
	//	delta_t	not set for TW_END
	//	delta_val	not set for TW_END
	
	tw_end->set_default_properties(tw_end_prop);
	//	Not Polled
	tw_end->set_disp_level(Tango::OPERATOR);
	tw_end->set_memorized();
	tw_end->set_memorized_init(true);
	att_list.push_back(tw_end);

	//	Attribute : config_changed
	config_changedAttrib	*config_changed = new config_changedAttrib();
	Tango::UserDefaultAttrProp	config_changed_prop;
	//	description	not set for config_changed
	//	label	not set for config_changed
	//	unit	not set for config_changed
	//	standard_unit	not set for config_changed
	//	display_unit	not set for config_changed
	//	format	not set for config_changed
	//	max_value	not set for config_changed
	//	min_value	not set for config_changed
	//	max_alarm	not set for config_changed
	//	min_alarm	not set for config_changed
	//	max_warning	not set for config_changed
	//	min_warning	not set for config_changed
	//	delta_t	not set for config_changed
	//	delta_val	not set for config_changed
	
	config_changed->set_default_properties(config_changed_prop);
	//	Not Polled
	config_changed->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(config_changed);

	//	Attribute : start_trigger_generator
	start_trigger_generatorAttrib	*start_trigger_generator = new start_trigger_generatorAttrib();
	Tango::UserDefaultAttrProp	start_trigger_generator_prop;
	start_trigger_generator_prop.set_description("Whether to use an internal trigger generator. Frequency controlled by another attribute. Currently hardcoded to 13.2 ns width positive TTL logic. If TRUE, START becomes an output");
	//	label	not set for start_trigger_generator
	//	unit	not set for start_trigger_generator
	//	standard_unit	not set for start_trigger_generator
	//	display_unit	not set for start_trigger_generator
	//	format	not set for start_trigger_generator
	//	max_value	not set for start_trigger_generator
	//	min_value	not set for start_trigger_generator
	//	max_alarm	not set for start_trigger_generator
	//	min_alarm	not set for start_trigger_generator
	//	max_warning	not set for start_trigger_generator
	//	min_warning	not set for start_trigger_generator
	//	delta_t	not set for start_trigger_generator
	//	delta_val	not set for start_trigger_generator
	
	start_trigger_generator->set_default_properties(start_trigger_generator_prop);
	//	Not Polled
	start_trigger_generator->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(start_trigger_generator);

	//	Attribute : last_run_valid_starts
	last_run_valid_startsAttrib	*last_run_valid_starts = new last_run_valid_startsAttrib();
	Tango::UserDefaultAttrProp	last_run_valid_starts_prop;
	//	description	not set for last_run_valid_starts
	//	label	not set for last_run_valid_starts
	//	unit	not set for last_run_valid_starts
	//	standard_unit	not set for last_run_valid_starts
	//	display_unit	not set for last_run_valid_starts
	//	format	not set for last_run_valid_starts
	//	max_value	not set for last_run_valid_starts
	//	min_value	not set for last_run_valid_starts
	//	max_alarm	not set for last_run_valid_starts
	//	min_alarm	not set for last_run_valid_starts
	//	max_warning	not set for last_run_valid_starts
	//	min_warning	not set for last_run_valid_starts
	//	delta_t	not set for last_run_valid_starts
	//	delta_val	not set for last_run_valid_starts
	
	last_run_valid_starts->set_default_properties(last_run_valid_starts_prop);
	//	Not Polled
	last_run_valid_starts->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(last_run_valid_starts);

	//	Attribute : last_run_empty_starts
	last_run_empty_startsAttrib	*last_run_empty_starts = new last_run_empty_startsAttrib();
	Tango::UserDefaultAttrProp	last_run_empty_starts_prop;
	//	description	not set for last_run_empty_starts
	//	label	not set for last_run_empty_starts
	//	unit	not set for last_run_empty_starts
	//	standard_unit	not set for last_run_empty_starts
	//	display_unit	not set for last_run_empty_starts
	//	format	not set for last_run_empty_starts
	//	max_value	not set for last_run_empty_starts
	//	min_value	not set for last_run_empty_starts
	//	max_alarm	not set for last_run_empty_starts
	//	min_alarm	not set for last_run_empty_starts
	//	max_warning	not set for last_run_empty_starts
	//	min_warning	not set for last_run_empty_starts
	//	delta_t	not set for last_run_empty_starts
	//	delta_val	not set for last_run_empty_starts
	
	last_run_empty_starts->set_default_properties(last_run_empty_starts_prop);
	//	Not Polled
	last_run_empty_starts->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(last_run_empty_starts);

	//	Attribute : last_run_hits
	last_run_hitsAttrib	*last_run_hits = new last_run_hitsAttrib();
	Tango::UserDefaultAttrProp	last_run_hits_prop;
	//	description	not set for last_run_hits
	//	label	not set for last_run_hits
	//	unit	not set for last_run_hits
	//	standard_unit	not set for last_run_hits
	//	display_unit	not set for last_run_hits
	//	format	not set for last_run_hits
	//	max_value	not set for last_run_hits
	//	min_value	not set for last_run_hits
	//	max_alarm	not set for last_run_hits
	//	min_alarm	not set for last_run_hits
	//	max_warning	not set for last_run_hits
	//	min_warning	not set for last_run_hits
	//	delta_t	not set for last_run_hits
	//	delta_val	not set for last_run_hits
	
	last_run_hits->set_default_properties(last_run_hits_prop);
	//	Not Polled
	last_run_hits->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(last_run_hits);

	//	Attribute : last_run_start_errors
	last_run_start_errorsAttrib	*last_run_start_errors = new last_run_start_errorsAttrib();
	Tango::UserDefaultAttrProp	last_run_start_errors_prop;
	//	description	not set for last_run_start_errors
	//	label	not set for last_run_start_errors
	//	unit	not set for last_run_start_errors
	//	standard_unit	not set for last_run_start_errors
	//	display_unit	not set for last_run_start_errors
	//	format	not set for last_run_start_errors
	//	max_value	not set for last_run_start_errors
	//	min_value	not set for last_run_start_errors
	//	max_alarm	not set for last_run_start_errors
	//	min_alarm	not set for last_run_start_errors
	//	max_warning	not set for last_run_start_errors
	//	min_warning	not set for last_run_start_errors
	//	delta_t	not set for last_run_start_errors
	//	delta_val	not set for last_run_start_errors
	
	last_run_start_errors->set_default_properties(last_run_start_errors_prop);
	//	Not Polled
	last_run_start_errors->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(last_run_start_errors);

	//	Attribute : start_trigger_generator_frequency
	start_trigger_generator_frequencyAttrib	*start_trigger_generator_frequency = new start_trigger_generator_frequencyAttrib();
	Tango::UserDefaultAttrProp	start_trigger_generator_frequency_prop;
	start_trigger_generator_frequency_prop.set_description("Frequency of internal trigger, in Hz");
	//	label	not set for start_trigger_generator_frequency
	start_trigger_generator_frequency_prop.set_unit("Hz");
	//	standard_unit	not set for start_trigger_generator_frequency
	//	display_unit	not set for start_trigger_generator_frequency
	//	format	not set for start_trigger_generator_frequency
	start_trigger_generator_frequency_prop.set_max_value("4000000");
	start_trigger_generator_frequency_prop.set_min_value("100");
	//	max_alarm	not set for start_trigger_generator_frequency
	//	min_alarm	not set for start_trigger_generator_frequency
	//	max_warning	not set for start_trigger_generator_frequency
	//	min_warning	not set for start_trigger_generator_frequency
	//	delta_t	not set for start_trigger_generator_frequency
	//	delta_val	not set for start_trigger_generator_frequency
	
	start_trigger_generator_frequency->set_default_properties(start_trigger_generator_frequency_prop);
	//	Not Polled
	start_trigger_generator_frequency->set_disp_level(Tango::OPERATOR);
	start_trigger_generator_frequency->set_memorized();
	start_trigger_generator_frequency->set_memorized_init(true);
	att_list.push_back(start_trigger_generator_frequency);

	//	Attribute : run_timeout
	run_timeoutAttrib	*run_timeout = new run_timeoutAttrib();
	Tango::UserDefaultAttrProp	run_timeout_prop;
	run_timeout_prop.set_description("The acquisition run timeout. To be applicable it requires at least one start pulse to arrive after timeout elapsed. \nThe device might still be busy for approx 100-200ms after that, but no timestamps are recorded.\nSet run_timeout to zero for infinite run");
	//	label	not set for run_timeout
	run_timeout_prop.set_unit("s");
	//	standard_unit	not set for run_timeout
	//	display_unit	not set for run_timeout
	//	format	not set for run_timeout
	run_timeout_prop.set_max_value("30744573456");
	run_timeout_prop.set_min_value("0");
	//	max_alarm	not set for run_timeout
	//	min_alarm	not set for run_timeout
	//	max_warning	not set for run_timeout
	//	min_warning	not set for run_timeout
	//	delta_t	not set for run_timeout
	//	delta_val	not set for run_timeout
	
	run_timeout->set_default_properties(run_timeout_prop);
	//	Not Polled
	run_timeout->set_disp_level(Tango::OPERATOR);
	run_timeout->set_memorized();
	run_timeout->set_memorized_init(true);
	att_list.push_back(run_timeout);

	//	Attribute : firmware_revision
	firmware_revisionAttrib	*firmware_revision = new firmware_revisionAttrib();
	Tango::UserDefaultAttrProp	firmware_revision_prop;
	firmware_revision_prop.set_description("Revision number of the FPGA configuration.");
	//	label	not set for firmware_revision
	//	unit	not set for firmware_revision
	//	standard_unit	not set for firmware_revision
	//	display_unit	not set for firmware_revision
	firmware_revision_prop.set_format("0x%08X");
	//	max_value	not set for firmware_revision
	//	min_value	not set for firmware_revision
	//	max_alarm	not set for firmware_revision
	//	min_alarm	not set for firmware_revision
	//	max_warning	not set for firmware_revision
	//	min_warning	not set for firmware_revision
	//	delta_t	not set for firmware_revision
	//	delta_val	not set for firmware_revision
	
	firmware_revision->set_default_properties(firmware_revision_prop);
	//	Not Polled
	firmware_revision->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(firmware_revision);

	//	Attribute : driver_version
	driver_versionAttrib	*driver_version = new driver_versionAttrib();
	Tango::UserDefaultAttrProp	driver_version_prop;
	driver_version_prop.set_description("Encoded version number.\nThe lower three bytes contain a triple level hierarchy of version numbers, e.g. 0x010103 encodes\nversion 1.1.3.\nA change in the first digit generally requires a recompilation of user applications. Change in the\nsecond digit denote significant improvements or changes that don't break compatibility and the\nthird digit changes with minor bug fixes and similar updates.");
	//	label	not set for driver_version
	//	unit	not set for driver_version
	//	standard_unit	not set for driver_version
	//	display_unit	not set for driver_version
	driver_version_prop.set_format("0x%08X");
	//	max_value	not set for driver_version
	//	min_value	not set for driver_version
	//	max_alarm	not set for driver_version
	//	min_alarm	not set for driver_version
	//	max_warning	not set for driver_version
	//	min_warning	not set for driver_version
	//	delta_t	not set for driver_version
	//	delta_val	not set for driver_version
	
	driver_version->set_default_properties(driver_version_prop);
	//	Not Polled
	driver_version->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(driver_version);

	//	Attribute : board_serial
	board_serialAttrib	*board_serial = new board_serialAttrib();
	Tango::UserDefaultAttrProp	board_serial_prop;
	board_serial_prop.set_description("Serial number.\nWith year and running number in 8.24 format. The number is identical to the one printed on\nthe silvery sticker on the board.");
	//	label	not set for board_serial
	//	unit	not set for board_serial
	//	standard_unit	not set for board_serial
	//	display_unit	not set for board_serial
	board_serial_prop.set_format("0x%08X");
	//	max_value	not set for board_serial
	//	min_value	not set for board_serial
	//	max_alarm	not set for board_serial
	//	min_alarm	not set for board_serial
	//	max_warning	not set for board_serial
	//	min_warning	not set for board_serial
	//	delta_t	not set for board_serial
	//	delta_val	not set for board_serial
	
	board_serial->set_default_properties(board_serial_prop);
	//	Not Polled
	board_serial->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(board_serial);

	//	Attribute : bin_size
	bin_sizeAttrib	*bin_size = new bin_sizeAttrib();
	Tango::UserDefaultAttrProp	bin_size_prop;
	bin_size_prop.set_description("Bin size (in ps) of the measured TDC data. The TDC main clock is running at\na frequency of 76.8 GHz resulting in a bin size of about 13.0208ps.");
	//	label	not set for bin_size
	//	unit	not set for bin_size
	bin_size_prop.set_standard_unit("ps");
	//	display_unit	not set for bin_size
	//	format	not set for bin_size
	//	max_value	not set for bin_size
	//	min_value	not set for bin_size
	//	max_alarm	not set for bin_size
	//	min_alarm	not set for bin_size
	//	max_warning	not set for bin_size
	//	min_warning	not set for bin_size
	//	delta_t	not set for bin_size
	//	delta_val	not set for bin_size
	
	bin_size->set_default_properties(bin_size_prop);
	//	Not Polled
	bin_size->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(bin_size);

	//	Attribute : CH0_Timestamps
	CH0_TimestampsAttrib	*ch0_timestamps = new CH0_TimestampsAttrib();
	Tango::UserDefaultAttrProp	ch0_timestamps_prop;
	//	description	not set for CH0_Timestamps
	//	label	not set for CH0_Timestamps
	//	unit	not set for CH0_Timestamps
	//	standard_unit	not set for CH0_Timestamps
	//	display_unit	not set for CH0_Timestamps
	//	format	not set for CH0_Timestamps
	//	max_value	not set for CH0_Timestamps
	//	min_value	not set for CH0_Timestamps
	//	max_alarm	not set for CH0_Timestamps
	//	min_alarm	not set for CH0_Timestamps
	//	max_warning	not set for CH0_Timestamps
	//	min_warning	not set for CH0_Timestamps
	//	delta_t	not set for CH0_Timestamps
	//	delta_val	not set for CH0_Timestamps
	
	ch0_timestamps->set_default_properties(ch0_timestamps_prop);
	//	Not Polled
	ch0_timestamps->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(ch0_timestamps);

	//	Attribute : CH1_Timestamps
	CH1_TimestampsAttrib	*ch1_timestamps = new CH1_TimestampsAttrib();
	Tango::UserDefaultAttrProp	ch1_timestamps_prop;
	//	description	not set for CH1_Timestamps
	//	label	not set for CH1_Timestamps
	//	unit	not set for CH1_Timestamps
	//	standard_unit	not set for CH1_Timestamps
	//	display_unit	not set for CH1_Timestamps
	//	format	not set for CH1_Timestamps
	//	max_value	not set for CH1_Timestamps
	//	min_value	not set for CH1_Timestamps
	//	max_alarm	not set for CH1_Timestamps
	//	min_alarm	not set for CH1_Timestamps
	//	max_warning	not set for CH1_Timestamps
	//	min_warning	not set for CH1_Timestamps
	//	delta_t	not set for CH1_Timestamps
	//	delta_val	not set for CH1_Timestamps
	
	ch1_timestamps->set_default_properties(ch1_timestamps_prop);
	//	Not Polled
	ch1_timestamps->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(ch1_timestamps);

	//	Attribute : CH2_Timestamps
	CH2_TimestampsAttrib	*ch2_timestamps = new CH2_TimestampsAttrib();
	Tango::UserDefaultAttrProp	ch2_timestamps_prop;
	//	description	not set for CH2_Timestamps
	//	label	not set for CH2_Timestamps
	//	unit	not set for CH2_Timestamps
	//	standard_unit	not set for CH2_Timestamps
	//	display_unit	not set for CH2_Timestamps
	//	format	not set for CH2_Timestamps
	//	max_value	not set for CH2_Timestamps
	//	min_value	not set for CH2_Timestamps
	//	max_alarm	not set for CH2_Timestamps
	//	min_alarm	not set for CH2_Timestamps
	//	max_warning	not set for CH2_Timestamps
	//	min_warning	not set for CH2_Timestamps
	//	delta_t	not set for CH2_Timestamps
	//	delta_val	not set for CH2_Timestamps
	
	ch2_timestamps->set_default_properties(ch2_timestamps_prop);
	//	Not Polled
	ch2_timestamps->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(ch2_timestamps);

	//	Attribute : CH3_Timestamps
	CH3_TimestampsAttrib	*ch3_timestamps = new CH3_TimestampsAttrib();
	Tango::UserDefaultAttrProp	ch3_timestamps_prop;
	//	description	not set for CH3_Timestamps
	//	label	not set for CH3_Timestamps
	//	unit	not set for CH3_Timestamps
	//	standard_unit	not set for CH3_Timestamps
	//	display_unit	not set for CH3_Timestamps
	//	format	not set for CH3_Timestamps
	//	max_value	not set for CH3_Timestamps
	//	min_value	not set for CH3_Timestamps
	//	max_alarm	not set for CH3_Timestamps
	//	min_alarm	not set for CH3_Timestamps
	//	max_warning	not set for CH3_Timestamps
	//	min_warning	not set for CH3_Timestamps
	//	delta_t	not set for CH3_Timestamps
	//	delta_val	not set for CH3_Timestamps
	
	ch3_timestamps->set_default_properties(ch3_timestamps_prop);
	//	Not Polled
	ch3_timestamps->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(ch3_timestamps);


	//	Create a list of static attributes
	create_static_attribute_list(get_class_attr()->get_attr_list());
	/*----- PROTECTED REGION ID(XTDC4Class::attribute_factory_after) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4Class::attribute_factory_after
}
//--------------------------------------------------------
/**
 *	Method      : XTDC4Class::pipe_factory()
 *	Description : Create the pipe object(s)
 *                and store them in the pipe list
 */
//--------------------------------------------------------
void XTDC4Class::pipe_factory()
{
	/*----- PROTECTED REGION ID(XTDC4Class::pipe_factory_before) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4Class::pipe_factory_before
	/*----- PROTECTED REGION ID(XTDC4Class::pipe_factory_after) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4Class::pipe_factory_after
}
//--------------------------------------------------------
/**
 *	Method      : XTDC4Class::command_factory()
 *	Description : Create the command object(s)
 *                and store them in the command list
 */
//--------------------------------------------------------
void XTDC4Class::command_factory()
{
	/*----- PROTECTED REGION ID(XTDC4Class::command_factory_before) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4Class::command_factory_before


	//	Command Start
	StartClass	*pStartCmd =
		new StartClass("Start",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pStartCmd);

	//	Command Stop
	StopClass	*pStopCmd =
		new StopClass("Stop",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pStopCmd);

	//	Command Off
	OffClass	*pOffCmd =
		new OffClass("Off",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pOffCmd);

	//	Command apply_config
	apply_configClass	*papply_configCmd =
		new apply_configClass("apply_config",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(papply_configCmd);

	/*----- PROTECTED REGION ID(XTDC4Class::command_factory_after) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4Class::command_factory_after
}

//===================================================================
//	Dynamic attributes related methods
//===================================================================

//--------------------------------------------------------
/**
 * method : 		XTDC4Class::create_static_attribute_list
 * description : 	Create the a list of static attributes
 *
 * @param	att_list	the ceated attribute list
 */
//--------------------------------------------------------
void XTDC4Class::create_static_attribute_list(vector<Tango::Attr *> &att_list)
{
	for (unsigned long i=0 ; i<att_list.size() ; i++)
	{
		string att_name(att_list[i]->get_name());
		transform(att_name.begin(), att_name.end(), att_name.begin(), ::tolower);
		defaultAttList.push_back(att_name);
	}

	cout2 << defaultAttList.size() << " attributes in default list" << endl;

	/*----- PROTECTED REGION ID(XTDC4Class::create_static_att_list) ENABLED START -----*/
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4Class::create_static_att_list
}


//--------------------------------------------------------
/**
 * method : 		XTDC4Class::erase_dynamic_attributes
 * description : 	delete the dynamic attributes if any.
 *
 * @param	devlist_ptr	the device list pointer
 * @param	list of all attributes
 */
//--------------------------------------------------------
void XTDC4Class::erase_dynamic_attributes(const Tango::DevVarStringArray *devlist_ptr, vector<Tango::Attr *> &att_list)
{
	Tango::Util *tg = Tango::Util::instance();

	for (unsigned long i=0 ; i<devlist_ptr->length() ; i++)
	{
		Tango::DeviceImpl *dev_impl = tg->get_device_by_name(((string)(*devlist_ptr)[i]).c_str());
		XTDC4 *dev = static_cast<XTDC4 *> (dev_impl);

		vector<Tango::Attribute *> &dev_att_list = dev->get_device_attr()->get_attribute_list();
		vector<Tango::Attribute *>::iterator ite_att;
		for (ite_att=dev_att_list.begin() ; ite_att != dev_att_list.end() ; ++ite_att)
		{
			string att_name((*ite_att)->get_name_lower());
			if ((att_name == "state") || (att_name == "status"))
				continue;
			vector<string>::iterator ite_str = find(defaultAttList.begin(), defaultAttList.end(), att_name);
			if (ite_str == defaultAttList.end())
			{
				cout2 << att_name << " is a UNWANTED dynamic attribute for device " << (*devlist_ptr)[i] << endl;
				Tango::Attribute &att = dev->get_device_attr()->get_attr_by_name(att_name.c_str());
				dev->remove_attribute(att_list[att.get_attr_idx()], true, false);
				--ite_att;
			}
		}
	}
	/*----- PROTECTED REGION ID(XTDC4Class::erase_dynamic_attributes) ENABLED START -----*/
	
	/*----- PROTECTED REGION END -----*/	//	XTDC4Class::erase_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Method      : XTDC4Class::get_attr_by_name()
 *	Description : returns Tango::Attr * object found by name
 */
//--------------------------------------------------------
Tango::Attr *XTDC4Class::get_attr_object_by_name(vector<Tango::Attr *> &att_list, string attname)
{
	vector<Tango::Attr *>::iterator it;
	for (it=att_list.begin() ; it<att_list.end() ; ++it)
		if ((*it)->get_name()==attname)
			return (*it);
	//	Attr does not exist
	return NULL;
}


/*----- PROTECTED REGION ID(XTDC4Class::Additional Methods) ENABLED START -----*/

/*----- PROTECTED REGION END -----*/	//	XTDC4Class::Additional Methods
} //	namespace
